{
  "title": "How to build custom DNS infrastructure",
  "tags": "mikhail,bahdashych,mikhail bahdashych,blog,dns,dnssec",
  "description": "",
  "pageDescription": "Let me guess, if you have ever heard about DNS and you have been playing around with those settings on your computer, the most thing you have done is change DNS server IP address from your local router to 1.1.1.1 or 8.8.8.8. Well, not bad, but what about building your own DNS infrastructure, huh? Sounds cool! You will have almost complete control over your network, but take your time, we will have time...",
  "intro": "This writeup contains different scenarios that you can utilize while building your own custom DNS infrastructure. Just your DNS cheatsheet.",
  "timestamp": "2023-03-25",
  "footer": "",
  "toc": {
    "intro": "Introduction",
    "reqs": "Prerequirements",
    "Scenarios": {
      "Configuration of Unbound DNS": {
        "dnsRecCachingResolver": "DNS Recursive Caching Resolver",
        "testDns": "Testing DNS over TLS and common DNS",
        "dnssecAndDot": "Enabling DNS over TLS and DNSSEC",
        "certificateGenerating": "How to generate self-signed certificates",
        "dotBetweenResolvers": "DNS over TLS Between 2 Resolvers",
        "dnsTlsEndpoints": "DNS over TLS for endpoints",
        "blockAd": "How to block Ad servers or other traffic"
      }
    },
    "conclusions": "Conclusions",
    "referencesAndContact": "References and contact"
  },
  "content": [
    {
      "type": "title",
      "content": "Introduction"
    },
    "Well, before we start our journey in the world of custom DNS servers, I'd like to tell a couple of words. First of all, I guess from the title of the article you figured out that we are going to build something, therefore it's going to be something very practical, and therefore, I am not going to discuss DNS from basics. If you want to know more about DNS welcome <a href='https://blog.mikhailbahdashych.me/en/blog/how-does-dns-work-and-why-we-need-dnssec' class='inline-link en'>here</a>, this article considers that you know what is the difference between DNS recursive resolver, root server, root nameserver etc.",
    "The second thing is that you should remember about that every case is unique. DNS is about roles, and roles are about just different sets of configuration. And I am going to describe here different scenarios of implementation, it would be more accurate to tell that here will be implemented just components. I just wanted to mention that because maybe you are looking for some specific use case that I will cover or not. So, I am not going to cover such cases. What I want to do instead is I want to just show how to build different components that you may or not use in your configuration, such as DoT communication between 2 DNS resolvers.",
    "The last thing I want to mention is that I am going to constantly update this writeup by adding (or editing, depending on issue) new configurations. So, you will see timestamp on what moment of time it was working version.",
    {
      "type": "title",
      "content": "Prerequirements"
    },
    "I guess I don't need to describe what you can or should use to build what you want. If you are here, I bet you already know what you want. Anyway, I'd to tell what I have been using while building and testing it so you won't be in trouble because of incompatibility.",
    {
      "type": "list-bullet",
      "items": [
        "<b>Raspberry PI Model 4B (Ubuntu Server 22.04)</b> — has been used as local instance in my local network.",
        "<b>AWS Ubuntu Server 22.04 (t2.micro)</b> — has been used as remote instance.",
        "<b>MacBook Pro 2019 Intel Core i5 (just my Mac)</b> — has been used as end client."
      ]
    },
    "As our server software we are going to use Unbound (version 1.13.1) and NSD.",
    {
      "type": "title",
      "content": "Scenarios"
    },
    "As I have mentioned above I am going to write about different cases you may find useful for what you can do with your infrastructure. Every scenarios is just configuration, you can easily mix them in order to build what you want. Just experiment, dude, this is how you learn!",
    {
      "type": "subtitle",
      "content": "Configuration of Unbound DNS"
    },
    "Unbound DNS Server is a powerful and flexible DNS resolver that is designed for speed and security. With Unbound DNS Server, you can have a reliable and secure DNS resolver that ensures fast and accurate resolution of DNS queries. The very first step as usual:",
    {
      "type": "code",
      "lang": "shell",
      "content": "$ sudo apt update && sudo apt upgrade\n$ sudo apt install unbound resolvconf"
    },
    "Probably you already noticed, except from Unbound itself, we are installing <span class='code-block'>resolvconf</span> package. Because of the fact that Unbound is going to replace default DNS stub-resolver of Ubuntu system and take its port, we will explicitly tell what DNS nameserver we are going to use.",
    {
      "type": "subsubtitle",
      "content": "DNS Recursive Caching Resolver"
    },
    "First of all, let's consider the scenario where we want to just replace default DNS server by ISP by our own custom one. So, how can we do that? Well, everything is quite easy, we need to set up <b>DNS Recursive Caching Resolver</b>. So, you can see that it has already 2 roles:",
    {
      "type": "list-bullet",
      "items": [
        "<b>Recursive</b> — recursive means that request of the DNS record is going to look like this: Give me what I need, and ask everyone you want.",
        "<b>Caching</b> — our server is going to store the records for some time. Usually, it's 24 hours."
      ]
    },
    "So, after installation of the server let's go to the Unbound configuration directory:",
    {
      "type": "code",
      "lang": "shell",
      "content": "$ cd /etc/unbound"
    },
    "Here is where Unbound configuration file is stored. Before we start editing this file, it would be nice to obtain one more thing — and this is file containing list of root servers. This file holds the information about root servers needed to initialize cache of Internet domain name servers.",
    {
      "type": "code",
      "lang": "shell",
      "content": "$ sudo ftp -o /etc/unbound/root.hints https://www.internic.net/domain/named.root"
    },
    "And now we are ready to go and to configure our DNS server. In configuration file you will also find my comments with description of different settings option that you can play with so you can change it to want you need. I won't be describing all of then since it's useless, but you can check the Unbound documentation.",
    "One important note for this configuration. This is very vanilla one. There is no neither DNSSEC (but we need to explicitly turn it off) nor DoT or DoH. Also, you need to consider IPv6 for your particular configuration, some networks and/or ISP just doesn't support this version of the Internet protocol so you may need to turn it off.",
    "Open <span class='code-block'>unbound.conf</span> file and paste next content:",
    {
      "type": "code",
      "lang": "shell",
      "content": "$ sudo nano unbound.conf"
    },
    {
      "type": "code",
      "lang": "nginx",
      "content": "# Unbound configuration file for Debian.\n#\n# See the unbound.conf(5) man page.\n#\n# See /usr/share/doc/unbound/examples/unbound.conf for a commented\n# reference config file.\n#\n# The following line includes additional configuration files from the\n# /etc/unbound/unbound.conf.d directory.\ninclude-toplevel: \"/etc/unbound/unbound.conf.d/*.conf\"\n\nremote-control:\n\tcontrol-enable: yes\n\tcontrol-use-cert: no\n\n# ---------------------------------------------\n# Server configuration\n# ---------------------------------------------\n\nserver:\n\t# Basically, this line tell us that interface is listened\n\t# to for queries from clients, and answers to client are give from it.\n\t# This line tells that our server is listening to all interfaces on port 53.\n\t# The fisrt one is for IPv4. The second one is for IPv4.\n\tinterface: 0.0.0.0@53\n\tinterface: ::1@53\n\n\taccess-control: 127.0.0.0/8 allow\n\taccess-control: 0.0.0.0/0 allow\n\taccess-control: ::0/0 allow\n\n# ---------------------------------------------\n# Functionality settings\n# ---------------------------------------------\n\nroot-hints: \"/etc/unbound/root.hints\"\n\n# Hide version and identity of the server\nhide-identity: yes\nhide-version: yes\n\ndo-ip4: yes\t# Enable IPv4\ndo-ip6: yes\t# Enable IPv6\ndo-udp: yes\t# Enable UDP\ndo-tcp: yes\t# Enable TCP\n\n# Optimizations. Change it depending on your instance\nnum-threads: 1\n# Number of ports to open. This number of file descriptors can be opened per thread.\noutgoing-range: 1024\n\n# Mininum and maximum time to live for cache. Number of hosts for which information is cached\ncache-min-ttl: 2400\ncache-max-ttl: 86400\ninfra-cache-numhosts: 100000\n\n# Use 0x20-encoded random bits in the query to foil spoof attempts\nuse-caps-for-id: yes\n\n# If yes, message cache elements are prefetched before they expire to keep the cache up to date.\n# Turning it on gives about 10 percent more traffic and load on the machine, but popular items do not expire from the cache.\nprefetch: yes\n\n# Have the validator print validation failures to the log.\n# Regardless of the verbosity setting.\nval-log-level: 2\n\n# Local Resolver Functions\ndo-not-query-localhost: no\n\n# ---------------------------------------------\n# DNS (Regular)\n# ---------------------------------------------\nforward-zone:\n\tname: \".\"\n\n\t# Regular DNS\n\tforward-addr: 1.1.1.1@53 # Cloudflare primary\n\tforward-addr: 1.0.0.1@53 # Cloudflare secondary\n\n\t# Google\n\tforward-addr: 8.8.8.8@53 # Google primary\n\tforward-addr: 8.8.4.4@53 # Google secondary\n\n\t# Quad9 (Slowest, only serve as backup when the faster are temporarily down.)\n\tforward-addr: 9.9.9.9@53  # Quad9 primary\n\tforward-addr: 9.9.9.10@53 # Quad9 secondary"
    },
    "Do not rush with restart of the Unbound server. We also want to make sure that even after reboot of the instance:",
    {
      "type": "list-bullet",
      "items": [
        "Our Unbound server will auto-start at boot time.",
        "The default DNS resolver will be 127.0.0.1 even after reboot."
      ]
    },
    "With the first one everything is quite easy:",
    {
      "type": "code",
      "lang": "shell",
      "content": "$ sudo systemctl enable unbound"
    },
    "Things are getting a little more interesting when it comes to the second thing. By default, Ubuntu runs the systemd-resolved stub resolver which listens on <span class='code-block'>127.0.0.53:53</span>. You need to stop it, so Unbound can bind to <span class='code-block'>0.0.0.0:53</span>. You can make sure, that systemd-resolved stub resolver utilizes port 53:",
    {
      "type": "code",
      "lang": "shell",
      "content": "$ sudo lsof -i:53\nCOMMAND    PID            USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\nsystemd-r  733 systemd-resolve   13u  IPv4  22619      0t0  UDP 127.0.0.53:domain\nsystemd-r  733 systemd-resolve   14u  IPv4  22620      0t0  TCP 127.0.0.53:domain (LISTEN)\nunbound   3447         unbound    3u  IPv6  32974      0t0  UDP localhost:domain\nunbound   3447         unbound    4u  IPv6  32975      0t0  TCP localhost:domain (LISTEN)\nunbound   3447         unbound    5u  IPv4  32976      0t0  UDP localhost:domain\nunbound   3447         unbound    6u  IPv4  32977      0t0  TCP localhost:domain (LISTEN)"
    },
    "Interesting, isn't it? You see, right now, after installation of the Unbound, it has been automatically set up, and this is why you see 2 different processes — Unbound and systemd-resolved — using the same port.",
    "Also, you can check <span class='code-block'>/etc/resolv.conf</span> file and see, that Unbound has replaced the default systemd-resolved stub resolver which listens on <span class='code-block'>127.0.0.53:53</span> with its own:",
    {
      "type": "code",
      "lang": "nginx",
      "content": "$ cat /etc/resolv.conf\n# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)\n#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN\n# 127.0.0.53 is the systemd-resolved stub resolver.\n# run \"systemd-resolve --status\" to see details about the actual nameservers.\n\nnameserver 127.0.0.1\noptions edns0 trust-ad"
    },
    "But don't think that everything is okay, first of all, previously, we have modified the Unbound, so we need to restart it, but, because of the fact that default Ubuntu utilizes this port right now, we will get an error, therefore, we need to disable systemd-resolved stub resolver:",
    {
      "type": "code",
      "lang": "shell",
      "content": "$ sudo systemctl disable systemd-resolved --now"
    },
    "This will ensure, that after restart of the Unbound server, systemd-resolved will not take that port 53. However, we have 2 more things to be completed:",
    {
      "type": "list-bullet",
      "items": [
        "Replace default DNS resolver with Unbound's one.",
        "Make sure that after reboot DNS resolver is the same as we have set."
      ]
    },
    "We need to make Ubuntu 22.04/20.04 server use 127.0.0.1 as DNS resolver, so Unbound will answer DNS queries. The Unbound package on Ubuntu ships with a systemd service <span class='code-block'>unbound-resolvconf.service</span> that is supposed to help us accomplish this. However, I found it won't work.",
    "Instead, you can create a custom <span class='code-block'>unbound-resolvconf.service</span> file.",
    {
      "type": "code",
      "lang": "shell",
      "content": "$ sudo nano /etc/systemd/system/unbound-resolvconf.service"
    },
    "Add the following lines in this file.",
    {
      "type": "code",
      "lang": "nginx",
      "content": "[Unit]\nDescription=local unbound via resolvconf\nAfter=unbound.service\nConditionFileIsExecutable=/sbin/resolvconf\n\n[Service]\nType=oneshot\nRemainAfterExit=yes\nExecStart=/bin/sh -c 'echo nameserver 127.0.0.1 | /sbin/resolvconf -a lo.unbound'\nExecStop=/sbin/resolvconf -d lo.unbound\n\n[Install]\nWantedBy=unbound.service"
    },
    "Save and close this file. Then reload systemd and restart this service.",
    {
      "type": "code",
      "lang": "shell",
      "content": "$ sudo systemctl daemon-reload\n$ sudo systemctl restart unbound-resolvconf.service"
    },
    "Now check the content of <span class='code-block'>/etc/resolv.conf</span>.",
    {
      "type": "code",
      "lang": "nginx",
      "content": "$ cat /etc/resolv.conf\n# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)\n#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN\n# 127.0.0.53 is the systemd-resolved stub resolver.\n# run \"systemd-resolve --status\" to see details about the actual nameservers.\n\nnameserver 127.0.0.1"
    },
    "And we are done here! Right now you have fully configured simple DNS recursive caching resolver. If you want to test that, just do a couple of <span class='code-block'>dig</span> commands. First of all, let's check if simple dig works. Then, we test it with TLS.",
    {
      "type": "code",
      "lang": "shell",
      "content": "root@raspberrypi:/etc/unbound# dig google.com\n\n; <<>> DiG 9.18.1-1ubuntu1.3-Ubuntu <<>> google.com\n;; global options: +cmd\n;; Got answer:\n;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 2312\n;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1\n\n;; OPT PSEUDOSECTION:\n; EDNS: version: 0, flags:; udp: 1232\n;; QUESTION SECTION:\n;google.com.\t\t\tIN\tA\n\n;; ANSWER SECTION:\ngoogle.com.\t\t2400\tIN\tA\t172.217.16.142\n\n;; Query time: 163 msec\n;; SERVER: 127.0.0.1#53(127.0.0.1) (UDP)\n;; WHEN: Sat Feb 25 15:00:09 CET 2023\n;; MSG SIZE  rcvd: 55"
    },
    "You can see that we use our localhost address in order to perform resolution requests. Now, let's check if DoT is enabled locally and if it actually works. To do that, we need to <span class='code-block'>+tls</span> flag:",
    {
      "type": "code",
      "lang": "shell",
      "content": "root@raspberrypi:/etc/unbound# dig google.com +tls\n;; Connection to 127.0.0.1#853(127.0.0.1) for google.com failed: connection refused.\n;; Connection to 127.0.0.1#853(127.0.0.1) for google.com failed: connection refused.\n;; Connection to 127.0.0.1#853(127.0.0.1) for google.com failed: connection refused.\n\nroot@raspberrypi:/etc/unbound# dig google.com +tls @1.1.1.1\n\n; <<>> DiG 9.18.1-1ubuntu1.3-Ubuntu <<>> google.com +tls @1.1.1.1\n;; global options: +cmd\n;; Got answer:\n;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 39720\n;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1\n\n;; OPT PSEUDOSECTION:\n; EDNS: version: 0, flags:; udp: 1232\n; PAD: (409 bytes)\n;; QUESTION SECTION:\n;google.com.\t\t\tIN\tA\n\n;; ANSWER SECTION:\ngoogle.com.\t\t235\tIN\tA\t142.250.186.206\n\n;; Query time: 83 msec\n;; SERVER: 1.1.1.1#853(1.1.1.1) (TLS)\n;; WHEN: Sat Feb 25 15:01:41 CET 2023\n;; MSG SIZE  rcvd: 468"
    },
    "You can see that it doesn't work for local request, but if we change the address of the DNS server using <span class='code-block'>@</span> to different (cloudflare, for instance), we can see that it actually works, and in SERVER section of the response we can see the IP address of cloudflare DNS server and port 853 which is responsible for DoT.",
    "What about DNSSEC? As I have mentioned at the beginning, we need to explicitly turn it off. Not a big deal, there is only line we need to comment out only one line in our configuration file.",
    {
      "type": "code",
      "lang": "nginx",
      "content": "auto-trust-anchor-file: \"/var/lib/unbound/root.key\""
    },
    "I guess (at least on my version of Unbound server — 1.13.1) you won't see this line in <span class='code-block'>unbound.conf</span> file, but actually it is. In order to find it go to <span class='code-block'>/ect/unbound/unbound.conf.d</span>. There you will find <span class='code-block'>root-auto-trust-anchor-file.conf</span> file which by default looks like this:",
    {
      "type": "code",
      "lang": "nginx",
      "content": "server:\n\t# The following line will configure unbound to perform cryptographic\n\t# DNSSEC validation using the root trust anchor.\n\tauto-trust-anchor-file: \"/var/lib/unbound/root.key\""
    },
    "Comment out this line and let's test if everything works (or doesn't work, in this case). However, there is one important thing that should be mentioned before, in order to make sure that DNSSEC works, while doing <span class='code-block'>dig</span> you should pay attention at 2 things — <span class='code-block'>AD</span> flag in <span class='code-block'>HEADER</span> section and <span class='code-block'>RRSIG</span> signature. Another important thing that should be mentioned is that not every domain name supports DNSSEC. Ok, enough theory, everything is better on examples.",
    "For the first dig we will take domain of cyberciti.biz and take a look on how it works by default, when DNSSEC is enabled on our side. In order to check that while doing dig put <span class='code-block'>+dnssec</span> option:",
    {
      "type": "code",
      "lang": "shell",
      "content": "root@raspberrypi:/etc/unbound# dig cyberciti.biz +dnssec\n\n; <<>> DiG 9.18.1-1ubuntu1.3-Ubuntu <<>> cyberciti.biz +dnssec\n;; global options: +cmd\n;; Got answer:\n;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 19105\n;; flags: qr rd ra ad; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1\n\n;; OPT PSEUDOSECTION:\n; EDNS: version: 0, flags: do; udp: 1232\n;; QUESTION SECTION:\n;cyberciti.biz.\t\t\tIN\tA\n\n;; ANSWER SECTION:\ncyberciti.biz.\t\t2400\tIN\tA\t172.66.43.53\ncyberciti.biz.\t\t2400\tIN\tA\t172.66.40.203\ncyberciti.biz.\t\t2400\tIN\tRRSIG\tA 13 2 300 20230228173208 20230226153208 34505 cyberciti.biz. jcb7Qtuld4Pdqv1BQGArBIEmBJwqh3aXWvjzzSeMXvZ5fBISOyEd9Y/o 6VIELt8jBtlYcf6pw7l745MhUxFX+A==\n\n;; Query time: 1068 msec\n;; SERVER: 127.0.0.1#53(127.0.0.1) (UDP)\n;; WHEN: Mon Feb 27 17:32:09 CET 2023\n;; MSG SIZE  rcvd: 183"
    },
    "Looking at this response we can make sure that DNSSEC is enabled — we have AD (Authentic Data): indicates the resolver believes the responses to be authentic - that is, validated by DNSSEC, we see RRSIG: cryptographic signature, in SERVER section we see that we are querying localhost, basically, our Unbound server. Now, we will comment out this line and take a look on what is going to happen:",
    {
      "type": "code",
      "lang": "shell",
      "content": "root@raspberrypi:/etc/unbound# dig cyberciti.biz +dnssec\n\n; <<>> DiG 9.18.1-1ubuntu1.3-Ubuntu <<>> cyberciti.biz +dnssec\n;; global options: +cmd\n;; Got answer:\n;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 1086\n;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1\n\n;; OPT PSEUDOSECTION:\n; EDNS: version: 0, flags: do; udp: 1232\n;; QUESTION SECTION:\n;cyberciti.biz.\t\t\tIN\tA\n\n;; ANSWER SECTION:\ncyberciti.biz.\t\t2400\tIN\tA\t172.66.40.203\ncyberciti.biz.\t\t2400\tIN\tA\t172.66.43.53\ncyberciti.biz.\t\t2400\tIN\tRRSIG\tA 13 2 300 20230228173722 20230226153722 34505 cyberciti.biz. KMI1240BcJb2EOdURgnujU/qUeClQOtQKYd46IoMT1MjYHc2Cuxn8l2E f6SmWgOD3d+dx39enUsQgN0tXCNOZA==\n\n;; Query time: 223 msec\n;; SERVER: 127.0.0.1#53(127.0.0.1) (UDP)\n;; WHEN: Mon Feb 27 17:37:22 CET 2023\n;; MSG SIZE  rcvd: 183"
    },
    "Okay, we still using our Unbound server, we still see <span class='code-block'>RRSIG</span> signature (but this signature was always, <span class='code-block'>+dnssec</span> just showed it), but there is no AD flag. It means, record is not validated, therefore, DNSSEC is disabled.",
    "There is still one thing you should consider though. If your server doesn't have DNSSEC enabled, it doesn't mean that server you are using as forwarding doesn't have it enabled also. Let's try to use other DNS server for address resolution, for example, cloudflare.",
    {
      "type": "code",
      "lang": "shell",
      "content": "root@raspberrypi:/etc/unbound# dig cyberciti.biz +dnssec @1.1.1.1\n\n; <<>> DiG 9.18.1-1ubuntu1.3-Ubuntu <<>> cyberciti.biz +dnssec @1.1.1.1\n;; global options: +cmd\n;; Got answer:\n;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 21077\n;; flags: qr rd ra ad; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1\n\n;; OPT PSEUDOSECTION:\n; EDNS: version: 0, flags: do; udp: 1232\n;; QUESTION SECTION:\n;cyberciti.biz.\t\t\tIN\tA\n\n;; ANSWER SECTION:\ncyberciti.biz.\t\t300\tIN\tA\t172.66.40.203\ncyberciti.biz.\t\t300\tIN\tA\t172.66.43.53\ncyberciti.biz.\t\t300\tIN\tRRSIG\tA 13 2 300 20230228174212 20230226154212 34505 cyberciti.biz. 6J5JY30o9nYfqO1uErRZvsQW8/bkIa4v/j7lNeSOkHiMjIGUydrNTvTL OGgH8tvY6XkAuULogNqJHinj21ltQw==\n\n;; Query time: 47 msec\n;; SERVER: 1.1.1.1#53(1.1.1.1) (UDP)\n;; WHEN: Mon Feb 27 17:42:12 CET 2023\n;; MSG SIZE  rcvd: 183"
    },
    "You see, we have disabled DNSSEC validation, but cloudflare DNS still has it enabled. Also, as I said, be careful with domain names you are using to test DNSSEC validation, for example, domain name google.com doesn't have DNSSEC, even when we are using DNS server that has DNSSEC validation.",
    {
      "type": "code",
      "lang": "shell",
      "content": "root@raspberrypi:/etc/unbound# dig google.com +dnssec @1.1.1.1\n\n; <<>> DiG 9.18.1-1ubuntu1.3-Ubuntu <<>> google.com +dnssec @1.1.1.1\n;; global options: +cmd\n;; Got answer:\n;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 63160\n;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1\n\n;; OPT PSEUDOSECTION:\n; EDNS: version: 0, flags: do; udp: 1232\n;; QUESTION SECTION:\n;google.com.\t\t\tIN\tA\n\n;; ANSWER SECTION:\ngoogle.com.\t\t190\tIN\tA\t142.250.203.206\n\n;; Query time: 35 msec\n;; SERVER: 1.1.1.1#53(1.1.1.1) (UDP)\n;; WHEN: Mon Feb 27 17:43:36 CET 2023\n;; MSG SIZE  rcvd: 55"
    },
    {
      "type": "subsubtitle",
      "content": "Testing DNS over TLS and common DNS"
    },
    "Now, let's discuss how we can turn on <b>DoT — DNS over TLS</b>. Actually, it's pretty easy, we just need to add a couple of lines to our configuration. Before that, I want to demonstrate you that this configuration actually works and to implement that I decided to sniff the traffic  to take a closer look at how it looks like from the network perspective.",
    "There tons of different tools you can use to sniff the traffic. The most common are <span class='code-block'>tcpdump</span> and <span class='code-block'>ettercap</span> so use whatever you like. In my case I have been using <span class='code-block'>ettercap</span> because my Unbound DNS server has been placed within my local network on my Raspberry PI. Basically, I just perform Man-in-the-middle attack and capture traffic between my router and Raspberry PI. <b>It's illegal, don't do that on NOT your own networks.</b>",
    "I performed 2 tests — the first one was for the basic (no DNS over TLS) configuration. For that test I used configuration you can find in the previous section. The second one was for the configuration with DoT. I slightly changed previous configuration (you can find it in a next section) to make it work over DoT.",
    "I used <span class='code-block'>dig google.com</span> for both tests and I also flushed the cache for this domain name before every test. And here is what I have got. For the basic configuration we have this picture:",
    {
      "type": "picture",
      "width": "w100",
      "resource": "no-dns-over-tls.jpeg"
    },
    "The IP address 192.168.8.112 is the IP address of Raspberry PI in my local network, and, as you can see, it sends plaintext DNS resolution requests for google.com to secondary cloudflare server with IP address 1.0.0.1.",
    "Let's flush the cache for this record, change our configuration file a bit to make it work over TLS and take a look at what we have got:",
    {
      "type": "picture",
      "width": "w80",
      "resource": "dns-over-tls.jpeg"
    },
    "Right now, as you can see, we have all traffic over TLS. We can tell that this is definitely DNS requests just by taking a look at source and destination IP addresses. In this case it's primary cloudflare DNS server.",
    "Now, with certainty that we were able to encrypt the traffic uses TLS we are going to change our configuration a bit.",
    {
      "type": "subsubtitle",
      "content": "Enabling DNS over TLS and DNSSEC"
    },
    "We are going to start securing our DNS connection by making it encrypted. DNS over TLS will provide traffic encryption between DNS servers. If we consider that I am going to use Raspberry Pi as my local DNS server, traffic from my computer to Raspberry Pi will by still in plaintext (this could be a problem as it's possible place for Man-in-the-Middle attack, but we will discuss that a little later), but from my Raspberry Pi to an external server, it's going to be already encrypted.",
    "So, here is how we are going to change our configuration to make it work via TLS:",
    {
      "type": "code",
      "lang": "nginx",
      "content": "# These certificates are used for authenticating connections made to outside peers.\ntls-cert-bundle: \"/etc/ssl/certs/ca-certificates.crt\"\n\nforward-zone:\n\tname: \".\"\n\t# Enabled or disable whether the queries to this forwarder use TLS for transport.\n\t# If you enable this, also configure a tls-cert-bundle: or use tls-win-cert: to load CA certs,\n\t# otherwise the connections cannot be authenticated.\n\tforward-tls-upstream: yes\n\n\t# Here, as you can see, we are using the same servers,\n\t# But instead of port 53, which is default DNS, \n\t# we are using 853, which is DNS over TLS\n\tforward-addr: 1.0.0.1@853 # Cloudflare secondary\n\tforward-addr: 1.1.1.1@853 # Cloudflare primary"
    },
    {
      "type": "subsubtitle",
      "content": "How to generate self-signed certificates"
    },
    "Before we start discussion about how we can encrypt traffic between 2 DNS resolver, we need to figure out how to generate certificates for them. Generally speaking, we have 2 approaches in this case:",
    {
      "type": "list-bullet",
      "items": [
        "We can create CSR and get it signed by CA.",
        "We can create self-signed certificate."
      ]
    },
    "Honestly, there is no big difference between them. As you probably already have guessed from title of this subtopic, we are going to generate self-signed certificate and the only additional thing we need to do in this case is to add this certificate to trusted (because of self-signing).",
    "We are not going to discuss all PKI infrastructure in this article, but if you are not familiar with that, I would highly recommend you to go <a href='https://blog.mikhailbahdashych.me/en/blog/pki-infrastructure-or-how-to-build-your-own-vpn' class='inline-link en'>here</a> and read about that (must have, in my opinion).",
    "So, first of all, create file named <span class='code-block'>config.cnf</span> and paste next content:",
    {
      "type": "code",
      "lang": "nginx",
      "content": "# --------------------------------------------------------------\n# First of all we need to generate certificates that we will use\n# to encrypt traffic between our servers. It can be either by CA\n# or, like here, self-signed one.\n# --------------------------------------------------------------\n# SSLeay example configuration file.\n#\n# Touch /home/user/.rnd\nRANDFILE \t= $ENV::HOME/.rnd\n\n[ req ]\ndefault_bits \t= 4096\ndefault_keyfile \t= privkey.pem\ndistinguished_name \t= req_distinguished_name\nprompt \t= no\npolicy \t= policy_anything\nreq_extensions = v3_req\n\n[ req_distinguished_name ]\ncountryName \t= US\nstateOrProvinceName \t= New York\nlocalityName \t= Troy\norganizationName \t= OrgName\norganizationalUnitName \t= IT\ncommonName \t= cn.commonname.org\nemailAddress \t= it@orgname.org\n\n[ v3_req ]\n# Extensions to add to a certificate request\nbasicConstraints = CA:FALSE\nkeyUsage = nonRepudiation, digitalSignature, keyEncipherment\nsubjectAltName = @alt_names\n\n[alt_names]\nDNS.1 = cn.commonname.org\n#DNS.2 = cisecurity.org\n#DNS.3 = www.example.com\n#DNS.4 = www.sub.example.com\n#DNS.5 = mx.example.com\n#DNS.6 = support.example.com"
    },
    "Change data in <span class='code-block'>req_distinguished_name</span> section and <span class='code-block'>alt_names</span> to your data. Next, use this command that will generate certificate and private key (change names, is you want).",
    {
      "type": "code",
      "lang": "nginx",
      "content": "# --------------------------------------------------------------\n# This is how we generate the certificate and the private key.\n# --------------------------------------------------------------\n$ openssl req -new -newkey rsa:4096 -x509 -sha256 -days 365 -nodes -out dns_server_cert.crt -keyout dns_key.key -config config.cnf"
    },
    "Now you have certificate and private key and we can move forward and start configure DNS over TLS between 2 DNS resolvers.",
    {
      "type": "subsubtitle",
      "content": "DNS over TLS Between 2 Resolvers"
    },
    "When two DNS resolvers communicate with each other using DoT, they first establish a TLS connection by exchanging certificates and negotiating encryption parameters. Once the connection is established, the client resolver sends a DNS query over the encrypted channel, and the server resolver sends back a response over the same channel. Because the entire exchange is encrypted, it's much harder for attackers to intercept or modify the DNS traffic.",
    "DoT between DNS resolvers provides an additional layer of security, privacy, and reliability for DNS traffic. By establishing a secure, encrypted channel between DNS resolvers, it can help prevent DNS-related attacks, improve the speed and reliability of DNS queries, and enable load balancing and redundancy. As more and more users and organizations prioritize security and privacy in their online activities, DoT is becoming an increasingly important protocol for secure and private DNS communications.",
    "I bet you can tell me: \"Okay, but what's the point of it? It seems like this is server-to-server communication, therefore, it's unlikely that someone is going eavesdropping my communication.\" Well, technically, you are right. You can use public DNS over TLS servers like one by cloudflare that has been already mention above — <b>1.1.1.1@853</b> — and when traffic will be leaving your network it'll be already encrypted, but we are considering different type of communication.",
    "Establishing of this communication may be useful, when you have one on-premise DNS server and one offsite. Therefore, you would like to encrypt this traffic. Also, before we start, I am going to show the structure of my network from the perspective of DNS protocol:",
    {
      "type": "code",
      "lang": "",
      "content": "MacBook --- Raspberry PI --- Router --- AWS Unbound Server --- Internet\n|__________Internal network________|_________External network_________|"
    },
    {
      "type": "list-bullet",
      "items": [
        "<b>Raspberry PI</b> — Internal DNS caching resolver.",
        "<b>AWS Unbound Server</b> — External DNS caching resolver."
      ]
    },
    "If we take a closer look at this structure right now we can notice a couple of things:",
    {
      "type": "list-numeric",
      "items": [
        "Depending on the configuration of the AWS Unbound Server this the traffic of this part of this scheme — <span class='code-block'>AWS Unbound Server --- Internet</span> — is going to be either encrypted or not. In the previous section we discussed how we can encrypt this traffic.",
        "For now, this part of the network — <span class='code-block'>MacBook --- Raspberry PI --- Router --- AWS Unbound Server</span> — is still transferring traffic in plain text. As you can see, traffic leaves our network unencrypted, we definitely don't want that. Yes, as it's been shown in previous section, I can use Raspberry PI as my local DNS server and make it forward traffic via port 853 using DNS over TLS, but in this scenario, I would have to use public DNS servers, like Cloudflare or Google, but we want to encrypt communication between 2 our servers.",
        "Maybe some of you noticed that even though we can encrypt traffic from internal caching resolver to the destination server, the traffic that goes from my Mac to Raspberry PI is still unencrypted, and this is the issue. Basically, we can protect traffic that leaves our network, but if someone is sniffing traffic internally, they can sniff it between my Mac and router as the plaintext. The problem of this situation is that it depend on what kind of system you have. Anyway, I am going to show you how you can protect against this."
      ]
    },
    "As you probably guessed, we are going to encrypt the traffic between Raspberry Pi and AWS Unbound server, to make it leave our network encrypted and to make AWS Unbound server be able to decrypt this traffic. Then, considering that we are utilizing DoT of Cloudflare, DNS Google or Quad9, AWS Unbound server will send this traffic to the Internet encrypted. Therefore, we will have only one place, where we should encrypt traffic to prevent Man-in-the-Middle attack — <span class='code-block'>MacBook --- Router</span>.",
    "First of all, we need to generate private key and certificate using configuration and command provided above. I have already done it on my Raspberry PI and put them into server's folder.",
    {
      "type": "code",
      "lang": "shell",
      "content": "root@raspberrypi:/etc/unbound# ll\ntotal 48\ndrwxr-xr-x   3 root root 4096 Feb 25 20:29 ./\ndrwxr-xr-x 101 root root 4096 Feb 25 13:00 ../\n-rw-r--r--   1 root root 1000 Feb 25 20:29 config.cnf\n-rw-------   1 root root 3272 Feb 25 20:29 dns_key.key\n-rw-r--r--   1 root root 2004 Feb 25 20:29 dns_server_cert.crt\n-rw-r--r--   1 root root 3314 Feb 25 07:50 root.hints\n-rw-r--r--   1 root root 2759 Feb 25 16:21 unbound.conf\ndrwxr-xr-x   2 root root 4096 Feb 25 15:17 unbound.conf.d/\n-rw-------   1 root root 2484 Feb 25 13:00 unbound_control.key\n-rw-r-----   1 root root 1501 Feb 25 13:00 unbound_control.pem\n-rw-------   1 root root 2484 Feb 25 13:00 unbound_server.key\n-rw-r-----   1 root root 1549 Feb 25 13:00 unbound_server.pem"
    },
    "Now, we need to do 2 things:",
    {
      "type": "list-bullet",
      "items": [
        "Install a root CA certificate in the trust store.",
        "Transfer this certificate and private key to the remote AWS Unbound server and change configuration a little."
      ]
    },
    "The first one is quite easy to do, but it's important to mention that even those there is no difference between <span class='code-block'>.pem</span> and <span class='code-block'>.crt</span> format unbound, there is still difference for installation process.",
    {
      "type": "code",
      "lang": "nginx",
      "content": "# --------------------------------------------------------------\n# On our local server we need to add this certificate to tursted\n# --------------------------------------------------------------\n$ sudo apt-get install -y ca-certificates\n$ sudo cp dns_server_cert.crt /usr/local/share/ca-certificates\n$ sudo update-ca-certificates"
    },
    "Now we have our certificate in trusted store, remember this line we put in our configuration for Raspberry PI Unbound server? This is where it is stored.",
    {
      "type": "code",
      "lang": "nginx",
      "content": "tls-cert-bundle: \"/etc/ssl/certs/ca-certificates.crt\""
    },
    "For the second one everything is also not so complicated. Using <span class='code-block'>scp</span>, or just copying, transfer both certificate and key to your other server and put them into Unbound directory.",
    {
      "type": "code",
      "lang": "nginx",
      "content": "# --------------------------------------------------------------\n# Send certificates to remote server\n# -------------------------------------------------------------- \n$ scp -i ssh.pem dns_* ubuntu@<ip-address-of-remote-server>:/tmp"
    },
    "On the remote server, move those 2 files to the Unbound directory and change ownership to root or unbound, depending on your configuration:",
    {
      "type": "code",
      "lang": "nginx",
      "content": "# -------------------------------------------------------------- \n# After cetificate and key have been send to                     \n# remote server we need to put then into unbound directory and   \n# and change ownership to either root or unbound user           \n# --------------------------------------------------------------\n$ cd /etc/unbound\n$ mv /tmp/dns_* .\n$ chown root:root dns_*"
    },
    "How, we need to modify our remote server configuration a little. First of all, we need to tell that from now on we are using 2 interfaces — port 53, which is common DNS, and port 853, which is DNS over TLS default port. Also, we need to point our server that it needs to use private key and certificate for encryption process.",
    "Also, as you probably noticed, in forward-zone we are forcing our server to use TLS and tell that only servers via DoT port 853 for our Unbound resolver are available to use. Also, as you can see, we set our certificate and private key to be able to use TLS connection:",
    {
      "type": "code",
      "lang": "nginx",
      "content": "# -----------------------------------------------------------------\n# Here, we need to add interface on port 853                        \n# add our certificate and private key                             \n# and (optionally, but recommended) use TLS also to forward traffic\n# -----------------------------------------------------------------\n\ninclude-toplevel: \"/etc/unbound/unbound.conf.d/*.conf\"\n\nserver:\n\tinterface: 0.0.0.0@53\n\tinterface: 0.0.0.0@853\n\n\ttls-service-key: \"/etc/unbound/dns_key.key\"\n\ttls-service-pem: \"/etc/unbound/dns_server_cert.crt\"\n\n\t# Enabled or disable whether the queries to this stub use TLS for transport.\n\ttls-upstream: yes\n\ttls-cert-bundle: \"/etc/ssl/certs/ca-certificates.crt\"\n\nforward-zone:\n\tname: \".\"\n\n\t# DNS over TLS\n\tforward-tls-upstream: yes\n\tforward-addr: 1.0.0.1@853 # Cloudflare secondary\n\tforward-addr: 1.1.1.1@853 # Cloudflare primary"
    },
    "But that's not it, we also need to change the configuration of the Raspberry PI to make it now forward traffic not to public DNS server (even though it was encrypted connection to Cloudflare), but to forward to to our remote DNS server.",
    "The only we need to change in the configuration file of our Raspberry PI Unbound server is <span class='code-block'>forward-zone</span> section. We need to set <span class='code-block'>forward-tls-upstream</span> to <span class='code-block'>yes</span> and change <span class='code-block'>forward-addr</span> to IP address of the remote server (don't forget about port 853):",
    {
      "type": "code",
      "lang": "nginx",
      "content": "# --------------------------------------------------------------\n# Also make sure that for forward-addr you use                   \n# IP address of your remote server                               \n# --------------------------------------------------------------\n\nforward-zone:\n\tname: \".\"\n\tforward-tls-upstream: yes\n\tforward-addr: <ip-address-of-remote-server>@853"
    },
    "So, what do we have in the result? Let's summarise! We are using 2 Unbound servers. The first one is on-premise located in our local network. It works on Raspberry PI. The second one is located within cloud. We have encrypted communication between them, so traffic leaves the network encrypted, in this form it goes to the remote server and then, also using DNS over TLS, is sent to the Internet — to an external DNS server. I have done a couple of tests and here is how.",
    "I performed traffic capturing between Raspberry PI and router to make sure that traffic leaves the network encrypted and I am still able to resolve domain name and get an IP address of requested resource.",
    "Once I have started traffic capturing, I flushed the cache of the local server and tried to resolve domain name. 192.168.8.112 is the IP address of the Raspberry PI on my local network.",
    {
      "type": "code",
      "lang": "shell",
      "content": "$ dig cyberciti.biz @192.168.8.112\n\n; <<>> DiG 9.10.6 <<>> cyberciti.biz @192.168.8.112\n;; global options: +cmd\n;; Got answer:\n;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 55757\n;; flags: qr rd ra ad; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1\n\n;; OPT PSEUDOSECTION:\n; EDNS: version: 0, flags:; udp: 1232\n;; QUESTION SECTION:\n;cyberciti.biz.\t\t\tIN\tA\n\n;; ANSWER SECTION:\ncyberciti.biz.\t\t2400\tIN\tA\t172.66.43.53\ncyberciti.biz.\t\t2400\tIN\tA\t172.66.40.203\n\n;; Query time: 534 msec\n;; SERVER: 192.168.8.112#53(192.168.8.112)\n;; WHEN: Sun Feb 26 11:55:30 CET 2023\n;; MSG SIZE  rcvd: 74"
    },
    {
      "type": "picture",
      "width": "w100",
      "resource": "end-to-end-dot.jpeg"
    },
    "And voila! We were able to resolve an IP address, and captured traffic shows us that it goes to the destination server via TLS. Great! Don't worry if it's too much for your, check my <a href='https://gist.github.com/bl4drnnr' class='inline-link en'>GitHub Gists</a> to find all configuration files.",
    "Also, here you can see proof that DNS traffic that goes from my computer to the router is still unencrypted, so, let's fix that.",
    {
      "type": "code",
      "lang": "nginx",
      "content": ";; SERVER: 192.168.8.112#53(192.168.8.112)"
    },
    "By the way, remember this network datagram? This is how we had this before establishing encrypted connection between 2 DNS resolvers:",
    {
      "type": "code",
      "lang": "",
      "content": "MacBook --- Raspberry PI --- Router --- AWS Unbound Server --- Internet\n|__________Internal network________|_________External network_________|\n|_____Unencrypted_______|__Unencrypted__|___ Encrypted (optionally)___|"
    },
    "And this is how it looks like after:",
    {
      "type": "code",
      "lang": "",
      "content": "MacBook --- Raspberry PI --- Router --- AWS Unbound Server --- Internet\n|__________Internal network________|_________External network_________|\n|_____Unencrypted_______|___Encrypted___|______Encrypted______________|"
    },
    "As you see, we have only last one place where we need to protect our network. And this is communicate between endpoint and on-premise DNS server.",
    {
      "type": "subsubtitle",
      "content": "DNS over TLS for endpoints"
    },
    {
      "type": "subsubtitle",
      "content": "How to block Ad servers or other traffic"
    },
    "But wait a second, if we are controlling all sources of the traffic, we can manipulate it, right? I have seen this spark in your eyes. You are 100% correct. If you're looking for a way to block ads or unwanted traffic on your network, using an Unbound DNS server is a powerful and flexible solution. By setting up an Unbound DNS server and configuring it to block queries to known ad servers and other problematic domains, you can greatly improve your browsing experience and protect your network from potential threats.",
    "Now, we are going to discuss how we can manipulate the traffic handled by our Unbound server. Honestly, here, we are going to talk mostly about blocking different Ad servers or just blocking traffic. Of course, you can, for example, change the IP address of cached domain and this way redirect the traffic, but you know, seems like shady zone, isn't it? Basically, it's possible to implement, but the only obstacle on your way is certificates. It won't be enough to just replace the domain with different IP address, you will also need to make client machines or other endpoints trust this certificate.",
    "Here, we are going to consider only the end implementation of it. What about sources of different Ad servers? Well, you will find a lot of them on the Internet, but for this example I used this <a href='https://github.com/StevenBlack/hosts' class='inline-link en'>repo</a>.",
    "One obvious thing is that, talking about infrastructure that we have build in previous sections, in this case, it doesn't matter, which server we will reconfigure to block the traffic.",
    {
      "type": "title",
      "content": "Conclusions"
    },
    "In conclusion, choosing the right DNS server configuration is crucial to ensure a reliable and secure internet browsing experience. Unbound and NSD DNS servers offer various configurations that can cater to different needs and preferences. From simple, standalone installations to more complex setups that involve load balancing and redundancy, there's a configuration that can suit your specific requirements. Whether you're a network administrator, a business owner, or a casual user, it's worth exploring these options to see how they can enhance your online experience. By leveraging the power of Unbound and NSD DNS servers, you can enjoy faster, safer, and more efficient internet browsing, regardless of your location or device.",
    "In today's article we have taken a look at different types of configurations that you may find useful for your own DNS infrastructure. Remember, there is no one switch that you can either turn on or turn off to enable of disable functions. It's always a set of different options that you may or not use. Everything is based on what role you want your DNS server to play and in what environment. Hope you found it useful, as I said, I am going to update this post time-to-time by adding new types of configuration sets or updating the old ones.",
    {
      "type": "title",
      "content": "References and contact"
    }
  ],
  "references": [{
    "name": "My GitHub gists with all configuration files",
    "link": "https://gist.github.com/bl4drnnr"
  }, {
    "name": "Comparison of DNS server software",
    "link": "https://en.wikipedia.org/wiki/Comparison_of_DNS_server_software"
  }, {
    "name": "Unbound configuration file documentation",
    "link": "https://unbound.docs.nlnetlabs.nl/en/latest/manpages/unbound.conf.html"
  }, {
    "name": "Set Up Unbound DNS Resolver on Ubuntu 22.04/20.04 Server",
    "link": "https://www.linuxbabe.com/ubuntu/set-up-unbound-dns-resolver-on-ubuntu-20-04-server"
  }, {
    "name": "Installing a root CA certificate in the trust store",
    "link": "https://ubuntu.com/server/docs/security-trust-store"
  }]
}
