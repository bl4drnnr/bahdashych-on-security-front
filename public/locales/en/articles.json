{
  "nextjs-nginx-deployment": {
    "title": "NextJS Nginx Deployment",
    "tags": "nextjs,nginx,deployment,mikhail,bahdashych,mikhail bahdashych,blog",
    "description": "NextJS Nginx deployment process",
    "pageDescription": "The process of deployment is always quite stressful, especially if you are developer and kind of not familiar with what DevOps team is doing. Well, here is the easiest solution on how you can deploy your Next.js application using Nginx and Let's encrypt for HTTPS secure communication. Your cheatsheet.",
    "intro": "Oh God, you have no clue how I used to be scared of everything beyond writing code. I used to think that it's something unreal complicated and dangerous since your mistake can destroy literally everything, but then I tried, and you know, it sounds much scary then it is in really. The only thing you need to do is to start from the basics.",
    "timestamp": "2023-02-17",
    "footer": "That's all for today guys. Thanks for reading, I hope this was helpful and solved the problem you came across here looking for a solution.",
    "toc": {
      "intro": "Introduction",
      "whyNginx": "Why Nginx?",
      "preps": "Preparations",
      "HTTPS Configuration": {
        "certGen": "Certificate generating",
        "nginxSec": "Nginx security configuration"
      },
      "nginxConfig": "Nginx configuration",
      "appConfig": "Application setup using pm2",
      "conclusion": "Conclusions and cheatsheet",
      "references": "Contact and references"
    },
    "content": [
      {
        "type": "title",
        "content": "Introduction"
      },
      "The process of deployment of the application is always kind of stress, especially when you are a developer, who has no idea of what DevOps staff does (trust me, I know what I am talking about). Therefore, the only thing you really want is to as fast as possible deploy your application in a more or less secure way.",
      "Well, congratulations, you have come to the right place! This article will explain how you can deploy your Next.js application using Nginx in a secure manner and HTTPS encryption. So, let's start!",
      {
        "type": "title",
        "content": "Why Nginx?"
      },
      "Nginx (pronounced 'engine-x') is a high-performance, open-source web server. It is a reverse proxy server, which means it is designed to pass incoming requests from clients to other servers for further processing. This can be useful in a variety of situations, such as serving static files, proxying requests to a backend server, or handling SSL encryption.",
      "Nginx is known for its stability, robustness, and low resource usage, making it a popular choice for web administrators and hosting providers. It can handle a large number of concurrent connections, making it well-suited for high-traffic websites and web applications. It also has a wide range of features and configuration options, including load balancing, caching, and access control.",
      "In addition to its use as a web server, Nginx can also be used as a reverse proxy, load balancer, and HTTP cache. This versatility, combined with its performance and stability, has made Nginx a popular choice among web developers and system administrators.",
      "Overall, Nginx is a powerful and flexible web server that is well-suited for a wide range of applications and use cases. Whether you are serving a simple website, running a large web application, or anything in between, Nginx is a great choice for your needs.",
      {
        "type": "title",
        "content": "Preparations"
      },
      "We are not going to discuss how and where you can spin up an instance and harder it (either AWS, DigitalOcean, Microsoft Azure or whatever cloud service provider you like). By the way, you can read about this here (LINK TO POST ABOUT INSTANCES HARDERING). Instead of it, we will focus on process of installation of Nginx, as our web server, and Let's encrypt, as our CA provider, considering you already have an instance for deployment.",
      "Using next 2 commands you will update all packages on your machine and installed required nginx and Let's encrypt:",
      {
        "type": "code",
        "lang": "shell",
        "content": "$ sudo apt update && sudo apt upgrade\n$ sudo apt install nginx letsencrypt"
      },
      "Also enable nginx in ufw:",
      {
        "type": "code",
        "lang": "shell",
        "content": "$ sudo ufw allow 'Nginx Full'"
      },
      "Very last step here is checking if our nginx sever is working correctly. In order to do that go to <span class='code-block'>/etc/nginx/sites-available/default</span> and paste next content (<span class='code-block'>*q</span> is our domain):",
      {
        "type": "code",
        "lang": "bash",
        "content": "$ sudo vim /etc/nginx/sites-available/default"
      },
      {
        "type": "code",
        "lang": "nginx",
        "content": "server {\n\tlisten 80 default_server;\n\tlisten [::]:80 default_server;\n\n\troot /var/www/html;\n\tindex index.html index.htm index.nginx-debian.html;\n\n\tserver_name q*;\n\n\tlocation / {\n\t\ttry_files $uri $uri/ =404;\n\t}\n\n\t# letsencrypt\n\tlocation ~ /.well-known {\n\t\tallow all;\n\t}\n}"
      },
      "Check for syntax errors and restart nginx:",
      {
        "type": "code",
        "lang": "shell",
        "content": "$ sudo nginx -t\nnginx: the configuration file /etc/nginx/nginx.conf syntax is ok\nnginx: configuration file /etc/nginx/nginx.conf test is successful\n$ sudo systemctl restart nginx"
      },
      {
        "type": "title",
        "content": "HTTPS Configuration"
      },
      "Let's Encrypt is a free, open-source, and automated certificate authority (CA) that provides digital certificates for Transport Layer Security (TLS) encryption. These certificates are used to secure web traffic and ensure that sensitive information, such as passwords and credit card numbers, are transmitted securely over the internet.",
      "The main goal of Let's Encrypt is to make encryption more accessible to the general public by offering free and easy-to-use certificates. Prior to Let's Encrypt, obtaining a certificate could be a complicated and expensive process. With Let's Encrypt, anyone can obtain a certificate with just a few clicks, making it possible to secure a website or web application with minimal effort.",
      "Let's Encrypt is also notable for its automated certificate issuance and renewal process. This means that once you have obtained a certificate, you don't need to worry about manually renewing it in the future. The certificate will automatically renew itself as long as the domain remains active and under your control.",
      "In summary, Let's Encrypt is a game-changing CA that is making encryption more accessible and affordable for everyone. With its free and easy-to-use certificates, automated renewal process, and commitment to open-source software, Let's Encrypt is a great choice for anyone looking to secure their website or web application.",
      {
        "type": "subtitle",
        "content": "Certificate generating"
      },
      "It's time to generate some TLS certificates. In this example we are going to use Let's Encrypt, but you can use any other CA provider you want. As it was mentioned previously, replace <span class='code-block'>*q</span> by your domain name:",
      {
        "type": "code",
        "lang": "shell",
        "content": "$ sudo letsencrypt certonly -a webroot --webroot-path=/var/www/html -d *q"
      },
      "Next command will generated DH Parameters. These parameters define how OpenSSL performs the Diffie-Hellman (DH) key-exchange. Basically, additional layer of security for your HTTPS connection:",
      {
        "type": "code",
        "lang": "shell",
        "content": "$ sudo openssl dhparam -out /etc/ssl/certs/dhparam.pem 2048"
      },
      {
        "type": "subtitle",
        "content": "Nginx security configuration"
      },
      "The thing we need to do is to secure our Nginx server by putting next configuration to ssl-params.conf config file. By using your favorite text editor (vim here) copy and paste next content:",
      {
        "type": "code",
        "lang": "shell",
        "content": "$ sudo vim /etc/nginx/snippets/ssl-params.conf"
      },
      {
        "type": "code",
        "lang": "bash",
        "content": "ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\nssl_prefer_server_ciphers on;\nssl_ciphers \"EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH\";\nssl_ecdh_curvesecp384r1;\nssl_session_cache shared:SSL:10m;\nssl_session_tickets off;\nssl_stapling on;\nssl_stapling_verify on;\n\nresolver 8.8.8.8 8.8.4.4 valid=300s;\nresolver_timeout 5s;\n\nadd_header Strict-Transport-Security \"max-age=63072000;includeSubdomains\";\nadd_header X-Frame-Options DENY;\nadd_headerX-Content-Type-Options nosniff;\n\nssl_dhparam /etc/ssl/certs/dhparam.pem;"
      },
      {
        "type": "title",
        "content": "Nginx configuration"
      },
      "We are almost done with the configuration. The 2 very last things we need to do is to configure our Nginx server as a reverse proxy server and start application.",
      "Let's start with configuration out Nginx as a reverse proxy. Basically, here we need to edit out nginx file and paste next content (remember, <span class='code-block'>*q</span> is for your domain name):",
      {
        "type": "code",
        "lang": "bash",
        "content": "$ sudo vim /etc/nginx/sites-available/default"
      },
      {
        "type": "code",
        "lang": "nginx",
        "content": "# redirect http to https\nserver {\n\tlisten 80 default_server;\n\tlisten [::]:80 default_server;\n\tserver_name *q;\n\treturn 301 https://$server_name$request_uri;\n}\n\nserver {\n\t# listen on *:443 -> ssl; instead of *:80\n\tlisten 443 ssl http2 default_server;\n\tlisten [::]:443 ssl http2 default_server;\n\n\tserver_name q*;\n\n\tssl_certificate /etc/letsencrypt/live/*q/fullchain.pem;\n\tssl_certificate_key /etc/letsencrypt/live/*q/privkey.pem;\n\tinclude snippets/ssl-params.conf;\n\n\tlocation / {\n\t\t# reverse proxy for next server\n\n\t\t# It is important to mention that you need to change port\n\t\t# for application on port application uses when is started\n\t\t# after build.\n\t\tproxy_pass http://localhost:8080;\n\t\tproxy_http_version 1.1;\n\t\tproxy_set_header Upgrade $http_upgrade;\n\t\tproxy_set_header Connection 'upgrade';\n\t\tproxy_set_header Host $host;\n\t\tproxy_cache_bypass $http_upgrade;\n\n\t\t# we need to remove this 404 handling\n\t\t# because next's _next folder and own handling\n\t\t# try_files $uri $uri/ =404;\n\t}\n\n\tlocation ~ /.well-known {\n\t\tallow all;\n\t}\n}"
      },
      "Restart the nginx service and the only thing we need to do is to set up our application as a daemon using pm2 process manager:",
      {
        "type": "code",
        "lang": "shell",
        "content": "$ sudo service nginx restart"
      },
      {
        "type": "title",
        "content": "Application setup using pm2"
      },
      "PM2 is a production process manager for Node.js applications. It is designed to keep your Node.js applications running and be able to recover from unexpected errors or crashes. PM2 provides features such as automatic restart, automatic log management, and process monitoring.",
      "PM2 makes it easy to run Node.js applications in the background as a daemon, without having to worry about the process being terminated or restarted. This is particularly useful for long-running Node.js applications, such as web servers or background workers, as it ensures that they are always available and can recover from any issues that may arise.",
      "In addition to its process management features, PM2 also provides powerful process monitoring capabilities. This includes detailed information about the status and performance of your Node.js applications, such as CPU and memory usage, as well as the ability to manage and inspect log files.",
      "PM2 is a popular tool for managing Node.js applications in production environments, as it makes it easy to keep your applications running and provides a wealth of information about their status and performance. Whether you are running a single Node.js application or multiple applications in a cluster, PM2 is a great tool for managing and monitoring your applications.",
      "Basically, here, we need to just build our application, install pm2 application globally and start the process of executed production build as a daemon in the background:",
      {
        "type": "code",
        "lang": "shell",
        "content": "$ npm run build # build our app for production (npm build script: next build)\n$ npm i -g pm2 # install pm2 to keep next app alive forever*\n$ pm2 start npm --name \"next\" -- start # start next app (npm start script: next start)\n"
      },
      "Enjoy your application in production mode and secured HTTPS connection! Below you will also find a couple afterwords and small guidebook on how you can manage your application using this process manager.",
      {
        "type": "title",
        "content": "Conclusions and cheatsheet"
      },
      "Was quite easy, huh? This is the easiest way to configure, deploy and secure your Next.js application using Nginx. But maybe you have a question like: \"Okay, that's fine, but what about CI/CD pipeline?\". Well, that is on yours. You can either configure it using GitHub Actions or Jenkins or whatever CI/CD pipeline tool you prefer. But if you want to know, how you can do deployment manually, here you go.",
      "The very first thing you need to do is to go to your server and go to folder with your project. There, pull the master (main) branch or whatever branch you use in production mode, install all packages, build the project (using npm in this particular example) and restart the pm2 process:",
      {
        "type": "code",
        "lang": "shell",
        "content": "$ git pull origin master\n$ npm i\n$ npm run build\n$ pm2 restart blog"
      },
      "By the way, I guess you want to change the name of the application on something more human-readable. Here is how you can do that. First of all type next command to get list of all processes handled by pm2:",
      {
        "type": "code",
        "lang": "shell",
        "content": "$ pm2 list"
      },
      "As a result you will see pretty looking table, take a look at the id column, at this moment, I guess, you will see 0 value, but if not, just replace it on your value and type next to change the name of the process:",
      {
        "type": "code",
        "lang": "shell",
        "content": "$ pm2 restart 0 --name \"new-name\""
      },
      "You are awesome! Cheatsheet specially for you:",
      {
        "type": "code",
        "lang": "bash",
        "content": "# Update and upgrade all packages and install required programs\n$ sudo apt update && sudo apt upgrade\n$ sudo apt install nginx letsencrypt"
      },
      {
        "type": "code",
        "lang": "bash",
        "content": "# Also enable nginx in ufw\n$ sudo ufw allow 'Nginx Full'"
      },
      {
        "type": "code",
        "lang": "bash",
        "content": "# Paste next content in sites-available/default file and test the server\n$ sudo vim /etc/nginx/sites-available/default"
      },
      {
        "type": "code",
        "lang": "nginx",
        "content": "# Replace *q with your domain name\nserver {\n\tlisten 80 default_server;\n\tlisten [::]:80 default_server;\n\n\troot /var/www/html;\n\tindex index.html index.htm index.nginx-debian.html;\n\n\tserver_name q*;\n\n\tlocation / {\n\t\ttry_files $uri $uri/ =404;\n\t}\n\n\t# letsencrypt\n\tlocation ~ /.well-known {\n\t\tallow all;\n\t}\n}"
      },
      {
        "type": "code",
        "lang": "bash",
        "content": "# Check for syntax error and restart the server\n$ sudo nginx -t\nnginx: the configuration file /etc/nginx/nginx.conf syntax is ok\nnginx: configuration file /etc/nginx/nginx.conf test is successful\n$ sudo systemctl restart nginx"
      },
      {
        "type": "code",
        "lang": "bash",
        "content": "# Generate the TLS certificate (replace *q with your domain name)\n$ sudo letsencrypt certonly -a webroot --webroot-path=/var/www/html -d *q"
      },
      {
        "type": "code",
        "lang": "bash",
        "content": "# Generate Diffie-Hellman (DH) params\n$ sudo openssl dhparam -out /etc/ssl/certs/dhparam.pem 2048"
      },
      {
        "type": "code",
        "lang": "bash",
        "content": "# Secure our Nginx server by pasting next into config file\n$ sudo vim /etc/nginx/snippets/ssl-params.conf"
      },
      {
        "type": "code",
        "lang": "bash",
        "content": "ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\nssl_prefer_server_ciphers on;\nssl_ciphers \"EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH\";\nssl_ecdh_curvesecp384r1;\nssl_session_cache shared:SSL:10m;\nssl_session_tickets off;\nssl_stapling on;\nssl_stapling_verify on;\n\nresolver 8.8.8.8 8.8.4.4 valid=300s;\nresolver_timeout 5s;\n\nadd_header Strict-Transport-Security \"max-age=63072000;includeSubdomains\";\nadd_header X-Frame-Options DENY;\nadd_headerX-Content-Type-Options nosniff;\n\nssl_dhparam /etc/ssl/certs/dhparam.pem;"
      },
      {
        "type": "code",
        "lang": "bash",
        "content": "# Paste next config into file\n# Remember about port of localhost and replacing *q with domain name\n$ sudo vim /etc/nginx/sites-available/default"
      },
      {
        "type": "code",
        "lang": "nginx",
        "content": "# redirect http to https\nserver {\n\tlisten 80 default_server;\n\tlisten [::]:80 default_server;\n\tserver_name *q;\n\treturn 301 https://$server_name$request_uri;\n}\n\nserver {\n\t# listen on *:443 -> ssl; instead of *:80\n\tlisten 443 ssl http2 default_server;\n\tlisten [::]:443 ssl http2 default_server;\n\n\tserver_name q*;\n\n\tssl_certificate /etc/letsencrypt/live/*q/fullchain.pem;\n\tssl_certificate_key /etc/letsencrypt/live/*q/privkey.pem;\n\tinclude snippets/ssl-params.conf;\n\n\tlocation / {\n\t\t# reverse proxy for next server\n\n\t\t# It is important to mention that you need to change port\n\t\t# for application on port application uses when is started\n\t\t# after build.\n\t\tproxy_pass http://localhost:8080;\n\t\tproxy_http_version 1.1;\n\t\tproxy_set_header Upgrade $http_upgrade;\n\t\tproxy_set_header Connection 'upgrade';\n\t\tproxy_set_header Host $host;\n\t\tproxy_cache_bypass $http_upgrade;\n\n\t\t# we need to remove this 404 handling\n\t\t# because next's _next folder and own handling\n\t\t# try_files $uri $uri/ =404;\n\t}\n\n\tlocation ~ /.well-known {\n\t\tallow all;\n\t}\n}"
      },
      {
        "type": "code",
        "lang": "bash",
        "content": "# Restart the service\n$ sudo service nginx restart"
      },
      {
        "type": "code",
        "lang": "shell",
        "content": "# Build and start the application\n$ npm run build # build our app for production (npm build script: next build)\n$ npm i -g pm2 # install pm2 to keep next app alive forever*\n$ pm2 start npm --name \"next\" -- start # start next app (npm start script: next start)\n"
      },
      {
        "type": "title",
        "content": "Contact and references"
      }
    ],
    "references": [{
      "name": "The original GitHub gist",
      "link": "https://gist.github.com/jjsquady/5399d6e1b23f501083a9c262d806e248"
    }]
  },
  "everything-you-need-to-know-about-hardening": {
    "title": "Everything you need to know about hardening",
    "tags": "",
    "description": "",
    "pageDescription": "Instance hardening refers to the process of securing an instance, which is a single occurrence of a virtual or physical machine that is running an operating system and hosting applications or services. The objective of instance hardening is to minimize the risk of unauthorized access to the instance, protect the data and applications hosted on it, and prevent any compromise of the system.",
    "intro": "",
    "timestamp": "",
    "footer": "",
    "toc": {
      "intro": "Introduction"
    },
    "content": {}
  },
  "pki-infrastructure-or-how-to-build-your-own-vpn": {
    "title": "PKI infrastructure or how to build your own VPN",
    "tags": "",
    "description": "",
    "pageDescription": "Have you ever thought about how VPN works? I think that this technology has become so much part of the modern business and all its infrastructure that we do not even think about it. And it would be worth it! Today we will discuss how we can build our infrastructure of VPN and generally find out how it all works.",
    "intro": "",
    "timestamp": "",
    "footer": "",
    "toc": {
      "intro": "Introduction"
    },
    "content": {}
  },
  "how-does-dns-work-and-why-we-need-dnssec": {
    "title": "How does DNS work and why we need DNSSEC",
    "tags": "mikhail,bahdashych,mikhail bahdashych,blog,dns,dnssec",
    "description": "Have you ever heard about DNS? I bet you have! Also I bet that if you tried to figure out what this is all about you have seen DNSSEC. Well... it's time to figure out how deep this rabbit hole actually is...",
    "pageDescription": "I guess all you guys have ever heard about DNS. This is phone book of the Internet, and it converts human-readable domain names into IP addresses parsed by machines and blah-blah-blah. Honestly, this is literally rabbit hole, and I have decided to figure out how deep it is. Well, trust me, you are going to be surprised and I have hella interesting stuff to share with you. So, let's dive into it!",
    "intro": "Rabbit hole — I guess this is the best description I found for DNS. I was enough naive to think that the only thing it does is converting domain names to IP address to ensure that human-readable names are understood by machines. I have no clue how wrong I was thinking that way.",
    "timestamp": "",
    "footer": "Pew... That was kinda complicated, wasn't it? But now you what DNS and DNSSEC actually are and how they work. If after reading you have even more questions than before, congratulations, from now on you will be able to find all answers on your own, but that's it for now. Thank you so much for reading.",
    "toc": {
      "intro": "Introduction",
      "DNS Overview": {
        "terminology": "DNS Terminology",
        "resolutionFlow": "DNS Resolution Flow",
        "DNS Servers Roles and Complete Lookup": {
          "stubResolver": "DNS Stub Resolver",
          "recursiveResolver": "DNS Recursive Resolver",
          "rootNameserver": "DNS Root Nameserver",
          "tldNameserver": "DNS TLD Nameserver",
          "authNameserver": "DNS Authoritative Nameserver",
          "rootNameserverVsRootServer": "DNS Root Nameserver vs DNS Root Server"
        },
        "DNS Records Types": {
          "aRec": "A Record (address)",
          "quadA": "AAAA Record (quad A)",
          "mxRec": "MX Record (Mail eXchange)",
          "nsRec": "NS Record (nameserver)",
          "cnameRec": "CNAME Record (Canonical Name)",
          "anameRec": "ANAME Record",
          "txtRec": "TXT Record"
        }
      },
      "dnsSecIssues": "DNS Security Issues",
      "DNSSEC Overview": {
        "terminology": "DNSSEC Terminology",
        "resolutionFlow": "DNSSEC Resolution Flow"
      },
      "dnssecSignCeremony": "The DNSSEC Root Signing Ceremony",
      "About DNS Encryption": {
        "dot": "DNS over TLS",
        "doh": "DNS over HTTPS",
        "difference": "Difference between DoT and DoH"
      },
      "conclusion": "Conclusions",
      "references": "Contact and references"
    },
    "content": [
      {
        "type": "title",
        "content": "Introduction"
      },
      "In today's digital age, the Domain Name System (DNS) plays a vital role in facilitating online communication and enabling users to access websites and services on the internet. However, with the increasing number of cybersecurity threats and malicious activities, there is a growing concern about the security of DNS and the potential risks associated with it.",
      "This is where DNS Security Extensions (DNSSEC) comes into the picture, offering a powerful solution to strengthen the security of DNS and protect against various attacks such as DNS spoofing, cache poisoning, and other forms of cyber threats.",
      "In this blog post, we'll take a closer look at what DNS and DNSSEC are, how they work, and why they are essential for maintaining a secure and reliable internet infrastructure. We'll also explore some real-world use cases and discuss the benefits and limitations of DNSSEC. So, if you want to learn more about DNS and DNSSEC and how they can help secure your online presence, keep reading!",
      {
        "type": "title",
        "content": "DNS Overview"
      },
      "The same as always let's start with short description what DNS actually is and how it can be described. The most popular definition of DNS always sounds more or less like that:",
      {
        "type": "list-bullet",
        "items": ["<b>DNS (Domain Name System)</b> — system that translates human-readable domain names to IP address, so machines can communicate with each other using those IP addresses."]
      },
      "Sounds pretty common, isn't it? I wanted to try to dig a little deeper in order to find out what happens after you write URL address into your browser and hit Enter button. I wanted to know what is happening behind the scene and how your computer obtains the IP address of source web server.",
      {
        "type": "subtitle",
        "content": "DNS Terminology"
      },
      "But before we start, let's define some terminology we are going to use all through our long journey. Feel free to get back to them whenever you need that:",
      {
        "type": "list-bullet",
        "items": [
          "<b>DNS Domain / DNS Zone</b> — a section of the DNS namespace. For instance: blog.mikhailbahdashych.me. (trailing dot is not a typo) is the server named \"blog\" in the \"mikhailbahdashych\" domain/zone, which is in the \"me\" domain/zone, which is in the \"root (.)\" domain/zone.",
          "<b>Iterative DNS Query</b> — a request to a DNS server: 'Give me whatever help you can, but ask no one else'.",
          "<b>Recursive DNS Query</b> — a request to a DNS server: 'Give me what I need, and ask everyone you want'.",
          "<b>DNS Server</b> — term that described the whole infrastructure of DNS roles. It's okay, if you don't understand it at this point, we will clarify that.",
          "<b>DNS Query or Request</b> — request for resolution of domain name to an IP address."
        ]
      },
      {
        "type": "subtitle",
        "content": "DNS Resolution Flow"
      },
      "The very first thing we need to know about is: how does your browser send some text in form of URL and get back IP address of requested website? At this moment of time we are discussing DNS only from perspective that the only thing it does is converting URLs into IP address of websites, but we will expand its usage a little later.",
      "Here is where <b>DNS Resolution Flow</b> comes into play. Everything is better on examples, so let's say you want to request for <b>cloudflare.com. (trailing dot is not a typo)</b>. First of all let me just introduce you the sequence of all requests, the whole resolution flow itself and then we discuss its parts step-by-step:",
      {
        "type": "list-numeric",
        "items": [
          "The client sends a recursive query to its local recursive caching DNS server for IP address of <b>\"cloudflare.com\"</b> webpage.",
          "The recursive caching DNS server sends an iterative query to a root (<b>\".\"</b>) nameserver for IP address of <b>\"cloudflare.com\"</b> webpage.",
          "The root nameserver responds with a referral to <b>\".com\"</b> zone's TLD nameserver.",
          "The recursive caching DNS server sends an iterative query to a <b>\".com\"</b> TLD nameserver for IP address of <b>\"cloudflare.com\"</b> webpage.",
          "The <b>\".com\"</b> TLD nameserver responds with a referral to <b>\"cloudflare\"</b> zone's authoritative nameserver.",
          "The recursive caching DNS server sends an iterative query to a <b>\"cloudflare\"</b> authoritative nameserver for IP address of <b>\"cloudflare.com\"</b> webpage.",
          "The <b>\"cloudflare\"</b> authoritative nameserver server responds with the IP address for <b>\"cloudflare.com\"</b>. webpage",
          "The recursive caching DNS server responds to the original client with the IP address of <b>\"cloudflare.com\"</b> (and caches it, if it had no this record).",
          "The client interacts with the web server <b>\"cloudflare.com\"</b>."
        ]
      },
      {
        "type": "picture",
        "width": "w80",
        "resource": "dns_record_request_sequence_recursive_resolver.png"
      },
      "Okay, smart ass, but about about subdomains, like for example <b>\"blog.cloudflare.com\"</b>? Not a big deal, the sequence will be expand for one more authoritative nameserver, which holds the IP address of that subdomain.",
      {
        "type": "picture",
        "width": "w80",
        "resource": "dns_record_request_sequence_cname_subdomain.png"
      },
      "Well, well, well, I see you have a lot questions. Okay, let's break this sequence down with step-by-step explanations of different types of nameservers. It's time to figure out everything about <b>DNS Servers Roles and Complete Lookup</b>.",
      {
        "type": "subtitle",
        "content": "DNS Servers Roles and Complete Lookup"
      },
      "The first thing you need to understand is that all those nameservers like root, TLD and blah-blah-blah are just roles. It literally can be just one physical machine (eiter virtual or not) which is responsible for handling almost every step of described sequence above. Also, I guess you have already notices, that there is some <b>hierarchy</b> of DNS servers, and that's true. All DNS roles are places in hierarchy that goes up from down.",
      "By the way, <b>let's consider that there is no caching on each step of the sequence</b>. You should know that <b>caching</b> is probably one of the most important function of the whole DNS. We want to make as few requests as possible in order to keep high performance of the system. Caching there is on literally every step of the DNS resolution flow.",
      "Also, let's update our sequence a little and let me introduce the whole <b>DNS lookup flow</b>. Just keep in mind this picture and get back to it after you read about each role to complete this pictuer inside your head and understand each step and role for the DNS lookup.",
      {
        "type": "picture",
        "width": "w100",
        "resource": "what_is_a_dns_server_dns_lookup.png"
      },
      "So, the very first thing that your DNS query meets is <b>DNS Stub Resolver</b>.",
      {
        "type": "subsubtitle",
        "content": "DNS Stub Resolver"
      },
      "<b>DNS Stub Resolver</b> — is an intermediate component between application that requiring DNS resolution and recursive DNS resolver. A DNS stub resolver is typically used by end-user devices, such as laptops, smartphones, and other networked devices, to look up domain names for websites and other online services.",
      "The operating system level DNS resolver is the second and last local stop before a DNS query leaves your machine. The process inside your operating system that is designed to handle this query is commonly called a <b>\"stub resolver\"</b> or <b>DNS client</b>. When a stub resolver gets a request from an application, it first checks its own cache to see if it has the record. If it does not, it then sends a DNS query (with a recursive flag set), outside the local network to a DNS recursive resolver inside the Internet service provider (ISP).",
      "I guess you have notices that there is no stub resolver on pictures, but that's fine. It's step between client and DNS recursive resolver. Basically, this is step where client checks if it already has the cached IP address of requested domain name. Also, for better understanding let's mark all steps where this role is involved. So, let's say it is <b>step 0</b>.",
      {
        "type": "subsubtitle",
        "content": "DNS Recursive Resolver"
      },
      "<b>DNS Recursive Resolver</b> — the recursive resolver is a component responsible for responses to a recursive request from a client and taking the time to track down the DNS record (usually 24h). It performs the task of resolving DNS queries by recursively traversing the DNS hierarchy. When a recursive resolver receives a DNS query from a client, it will query other DNS servers on behalf of the client to resolve the domain name to an IP address.",
      "<b>DNS Recursive Resolver is the connecting link of the whole flow.</b>",
      "One of the key benefits of using a recursive resolver is that it can <b>cache</b> DNS records to improve the efficiency of subsequent DNS queries. This is why also going to refer to it as to <b>DNS caching server</b>. When a recursive resolver receives a DNS response, it will store the response in its cache for a period of time (known as the time-to-live, or TTL), so that it can quickly respond to future queries for the same domain name. This can help to reduce the load on the DNS system and improve the performance of DNS lookups.",
      "Here is where everything starts. The client (end user) sends a recursive query to its local recursive caching DNS server for <b>cloudflare.com</b>. This is <b>step 1</b>",
      {
        "type": "subsubtitle",
        "content": "DNS Root Nameserver"
      },
      "<b>DNS Root Nameserver</b> — the root nameserver <b>(DNS Root Nameserver ≠ DNS Root Server!!! We'll discuss that later)</b> is the first step in translating (resolving) human readable host names into IP addresses. Remember that dot in domain name, that wasn't typo? This is where root nameserver comes into play.",
      "The recursive caching server sends an iterative query to a root <b>\".\"</b> nameserver for <b>cloudflare.com</b> — <b>step 2</b>. The root nameserver responds with referral to <b>\".com\"</b> zone's nameserver. But what is <b>\".com\"</b>, of course, it's top-level domain! The root server responds with a referral to <b>\".com\"</b> zone's TLD nameservers.",
      {
        "type": "subsubtitle",
        "content": "DNS TLD Nameserver"
      },
      "<b>DNS TLD Nameserver</b> — TLD stands for top-level domain. TLD nameserver maintains information for all the domain names that share a common domain extension, such as <b>.com</b, <b>.net</b>, or whatever comes after the last dot in a URL. For example, a <b>\".com\"</b> TLD nameserver contains information for every website that ends in <b>\".com\"</b>.",
      "The recursive caching DNS server sends an iterative query to a <b>\".com\"</b> server for cloudflare.com — <b>step 4</b>. TLD Nameserver responds with a referral to cloudflare zone's authoritative nameserver — <b>step 5</b>.",
      {
        "type": "subsubtitle",
        "content": "DNS Authoritative Nameserver"
      },
      "<b>DNS Authoritative Nameserver</b> — this final nameserver can be thought of as a dictionary on a rack of books, in which a specific name can be translated into its definition. The authoritative nameserver is the last stop in the nameserver query. If the authoritative nameserver has access to the requested record, it will return the IP address for the requested hostname back to the DNS Recursor that made the initial request.",
      "The recursive caching DNS server sends an iterative query to a <b>cloudflare</b> server for <b>cloudflare.com</b> — <b>step 6</b>. The cloudflare server responds with the IP address for <b>cloudflare.com</b> — <b>step 7</b>. The recursive caching DNS server responds to the original client with the IP address of <b>cloudflare.com</b> — <b>step 8</b> — and client interacts with the web server <b>cloudflare.com</b> — <b>steps 9 and 10</b>.",
      "Well done, that's it about DNS lookups. Now you know how it works and what components are involved. Probably you have noticed that there are a lot of \"DNS Servers\". When I say \"DNS server\" I literally mean this whole flow because DNS server just combines inside all roles.",
      {
        "type": "subsubtitle",
        "content": "DNS Root Nameserver vs DNS Root Server"
      },
      "Remember that pictured titled <b>Complete DNS Lookup and Webpage Query</b>. There is one huge mistake on that picture. You see, step 2 and 3 tell about about communication with <b>DNS Root Server</b>, but in reality, it's <b>DNS Root Nameserver</b>. It is extremely important to differ them. So, let me explain the difference:",
      {
        "type": "list-bullet",
        "items": [
          "<b>DNS Root Servers</b> — are the 13 authoritative name servers that are responsible for responding to queries for the root zone of the Domain Name System (DNS). These servers are operated by various organizations around the world and are identified by letters A through M. They are the first step in the process of resolving a domain name to an IP address and help to direct traffic to the appropriate top-level domain (TLD) nameserver.",
          "<b>DNS Root Nameservers</b> — set of nameservers that serve the root zone of the DNS. These nameservers are responsible for providing referrals to the TLD nameservers and other authoritative nameservers, and they play a critical role in the functioning of the DNS. The term \"root nameserver\" is often used interchangeably with \"root server,\" but strictly speaking, the former refers specifically to the nameservers that serve the root zone."
        ]
      },
      {
        "type": "subtitle",
        "content": "DNS Records Types"
      },
      "At the beginning of our path I told that until some point of time we should consider DNS as something converting URLs into IP address of websites. Technically, this is true, but only partly. DNS is responsible for converting <b>every human-readable resource name into IP address</b>. It not only includes web sites (IPv4 and IPv6), but also email servers, for instance. Those are called <b>DNS records types</b>. Let's briefly discuss most important of them.",
      {
        "type": "subsubtitle",
        "content": "A Record (address)"
      },
      "<b>A Record (address)</b> — shows the IP address for a specific hostname or domain. Works for IPv4 type only. The main usage of it is for IP address lookup. Using an A record, a web browser is able to load a website using the domain name.",
      {
        "type": "subsubtitle",
        "content": "AAAA Record (quad A)"
      },
      "<b>AAAA Record (quad A)</b> — just like A record points to the IP address for a domain, buy instead of using IPv4, uses IPv6. The main usage of if is the same as for A type, but resolving a domain name to the newer IPv6 protocol address. Mobile phones prefer IPv6, if it's available.",
      {
        "type": "subsubtitle",
        "content": "MX Record (Mail eXchange)"
      },
      "<b>MX Record (Mail eXchange)</b> — makes possible to direct emails to a mail server by showing where emails for a domain should be routed to. You can have multiple MX records for a single domain name — basically, just backup email severs. The lower priority value for the server, the more important it is. And in case when primary server goes down, the secondary server will be used - active-active scheme.",
      "The main usage of it is to map where email should be delivered. Should point to a mail server name and not to an IP address. <b>ANAME</b> — can point to a mail server name or an IP address.",
      {
        "type": "subsubtitle",
        "content": "NS Record (nameserver)"
      },
      "<b>NS Record (nameserver)</b> — specifies the authoritative DNS server for a domain. In other words, the NS record helps point to where internet application like a web browser can find the IP address for a domain name. Usually, multiple nameservers are specified for a domain. The main usage of those authoritative servers is to connect your domain name to the actual server your site is hosted on. The nameservers contains other DNS records like MX or A records.",
      {
        "type": "subsubtitle",
        "content": "CNAME Record (Canonical Name)"
      },
      "<b>CNAME record (Canonical Name)</b> — is a DNS records that points a domain name (an alias) to another domain. In a CNAME record, the alias doesn't point to an IP address. And the domain name that the alias points to is the canonical name.",
      "For example, the subdomain ng.example.com (ng.example.com is a CNAME Record) can point to example.com using CNAME. Here example.com points to the actual IP address using an A record.",
      "The main usage of it is running multiple subdomains for different purposes on the same server. For example, we have ftp.example.com and www.example.com. We can then use a CNAME record to point both subdomains to example.com. The main domain example.com then points to the server's IP address using an A record. It's also possible for one CNAME to point to other CNAME. However, doing so is inefficient and can lead to slow load speed and poor user experience.",
      "Usually points to a load balancer.",
      {
        "type": "subsubtitle",
        "content": "ANAME Record"
      },
      "<b>ANAME (ALIAS)</b> — combination of CNAME and A types of records. ANAME is not a read DNS record but a way of simulating it. And that's why it is called Alias name. Just like CNAME, ANAME maps one domain name to another. So, an ANAME is configured to point to another domain. When the domain name an ANAME points to is queried by the client browser, it responds with an IP address. A CNAME, on the other hand, cannot point to an IP address, but an ANAME can.",
      "Was used in the past, CNAME is a king nowadays. Shouldn't point to a load balancer.",
      {
        "type": "subsubtitle",
        "content": "TXT Record"
      },
      "<b>TXT Record (Text Record)</b> — is the type of record that allows administrator to add human-readable (and machine-readable) notes in the DNS. Doesn't require specific format. Used to provide the ability to associate arbitrary text with a host or other name, such as human readable information about a server, network, data center, or other accounting information",
      "The main usage of it nowadays is to prevent email spam and verify domain ownership. Here we should talk about DMARC, SPF and DKIM, but for now just know that those are about <b>anti-span security</b>.",
      {
        "type": "title",
        "content": "DNS Security Issues"
      },
      "Okay, now we have a complete overview of how DNS resolution works, what are different roles of DNS servers and even mentioned a couple of main record types, but what about security issues? Actually, we have only 2 main security issues — <b>lack of authentication and confidentiality</b>.",
      "The first is due to the fact that DNS has no ability to check if the record it has requested comes from trusted source, and this issue is mitigated by <b>DNSSEC</b>.",
      "The second is due to the fact that DNS as a protocol has been implemented in early 80's. As you already know, at that period of time, security wasn't on the foreground while all resources have been concentrated on providing just availability. Therefore, DNS, as many other protocols such as HTTP or ART, is transmitting data in plaintext. This issue is mitigated by <b>encryption</b>.",
      "Fine, we are definitely going to discuss both of the issues, but let's first take a look at how DNS looks like when it has been hacked:",
      {
        "type": "list-numeric",
        "items": [
          "The client sends a recursive query to its local recursive caching DNS server for IP address of <b>\"cloudflare.com\"</b> webpage.",
          "The recursive caching DNS server sends an iterative query to a root (<b>\".\"</b>) nameserver for IP address of <b>\"cloudflare.com\"</b> webpage.",
          "The root nameserver responds with a referral to <b>\".com\"</b> zone's TLD nameserver.",
          "The recursive caching DNS server sends an iterative query to a <b>\".com\"</b> TLD nameserver for IP address of <b>\"cloudflare.com\"</b> webpage.",
          "The <b>\".com\"</b> TLD nameserver responds with a referral to <b>\"cloudflare\"</b> zone's authoritative nameserver.",
          "The recursive caching DNS server sends an iterative query to a <b>\"cloudflare\"</b> authoritative nameserver for IP address of <b>\"cloudflare.com\"</b> webpage.",
          "The evil DNS server responds with the evil IP address for <b>\"cloudflare.com\"</b>.",
          "The recursive caching DNS server responds to the original client with the evil IP address for <b>\"cloudflare.com\"</b>.",
          "Client interacts with the evil web server, which either respond directly, or perform <b>Man-in-the-Middle</b> attack operation by passing and observing (or altering) traffic from/to the legitimate web server."
        ]
      },
      {
        "type": "picture",
        "width": "w70",
        "resource": "dns_poisoning.jpeg"
      },
      "As you can see, from step 1 to 6 we have exactly the same flow, problems start from step 7.",
      "It's called <b>DNS spoofing/cache poisoning</b> — this is an attack where forged DNS data is introduced into a DNS resolver's cache, resulting in the resolver returning an incorrect IP address for a domain. Instead of going to the correct website, traffic can be diverted to a malicious machine or anywhere else the attacker desires; often this will be a replica of the original site used for malicious purposes such as distributing malware or collecting login information.",
      "So, we need to somehow verify that response comes from trusted source, right? Basically, provide <b>authentication</b> — this is where <b>DNSSEC</b> comes into play.",
      {
        "type": "title",
        "content": "DNSSEC Overview"
      },
      "Finally, here we are, DNSSEC! We should consider that DNS and DNSSEC now are like HTTP and HTTPS ~20 years ago. It will be just required to use by everyone in order to provide secure communication. DNSSEC and HTTPS are even similar in some cases.",
      "HTTPS provide both <b>authentication</b> and <b>confidentiality</b> using PKI infrastructure of CA's (if you are not familiar with <a href='https://blog.mikhailbahdashych.me/en/blog/pki-infrastructure-or-how-to-build-your-own-vpn' class='inline-link en'>see here</a>). <b>Authentication</b> is provided by verifying who was the issuer of the certificate, while <b>confidentiality</b> is provided by encrypting traffic.",
      "In case of DNSSEC, it provides only <b>authentication</b>, where DNS encryption provides <b>confidentiality</b>, what was already mentioned above. But getting back to DNSSEC, let's start with simple definition of what it actually is:",
      {
        "type": "list-bullet",
        "items": [
          "<b>DNSSEC (DNS Security Extension)</b> — is an authentication mechanism that utilises PKI cryptography to prevent spoofing. With DNSSEC, it's not DNS queries and responses themselves are cryptographically signed, but rather DNS data itself signed by the owner of the data."
        ]
      },
      "Remember where we mentioned that DNS has hierarchical structure? The example of DNSSEC will make it even more obvious. Assuming that you are already familiar with PKI and cryptography, we need to introduce a couple of new terms especially for DNSSEC.",
      {
        "type": "subtitle",
        "content": "DNSSEC Terminology"
      },
      {
        "type": "list-bullet",
        "items": [
          "<b>RRSet - Resource Record Set</b> — the first step towards securing a zone with DNSSEC is to group all the records with the same type into a resource record set (RRset). For example, if you have three AAAA records in your zone on the same label (i.e. label.example.com), they would all be bundled into a single AAAA RRset.\n\nIt's actually this full RRset that gets digitally signed, opposed to individual DNS records. Of course, this also means that you must request and validate all of the AAAA records from a zone with the same label instead of validating only one of them. In short — <b>a set of records with the same type and same domain/zone</b>."
        ]
      },
      {
        "type": "picture",
        "width": "w80",
        "resource": "diagram-rrsets.svg"
      },
      {
        "type": "list-bullet",
        "items": [
          "<b>DNSKEY</b> — contains a public signing key.",
          "<b>RRSig - Resource Record Signature</b> — a record containing RRSet's digital signature.",
          "<b>ZSK - Zone Signing Key</b> — <b>used to sign or verify a domain's/zone's non-key records (A, AAAA, MX etc.)</b>. In DNSSEC, each zone has a pair of zone-signing keys (ZSK), where the private key signs each RRset in the zone while the public key verifies the signature. To implement DNSSEC, a zone operator uses the private ZSK to create digital signatures for each RRset and stores them as RRSig records in their nameserver.\n\nHowever, the RRSig records alone cannot be used by DNS resolvers to verify the signatures. To enable this, the zone operator adds their public ZSK to their nameserver in a DNSKEY record.\n\nWhen a DNSSEC resolver requests a record type, the nameserver returns the corresponding RRSig along with the RRset. The resolver can then retrieve the public ZSK from the DNSKEY record on the nameserver. The RRset, RRSig, and public ZSK together can validate the response.\n\nTrusting the zone-signing key in the DNSKEY record also means trusting all records in the zone. But if the ZSK is compromised, it is crucial to validate the public ZSK to ensure security."
        ]
      },
      {
        "type": "picture",
        "width": "w60",
        "resource": "diagram-zone-signing-keys-2.svg"
      },
      {
        "type": "list-bullet",
        "items": [
          "<b>KSK - Key Signing Key</b> — <b>used to sign or verify a domain's/zone's keys</b>. In addition to the zone-signing key, DNSSEC nameservers utilize a key-signing key (KSK). Similar to how the ZSK provided security for the RRsets in the previous section, the KSK validates the DNSKEY record by signing the public ZSK, thereby generating an RRSIG for the DNSKEY.\n\nThe public KSK is also published in a DNSKEY record by the nameserver, just like the public ZSK, which results in the DNSKEY RRSet. Both the public KSK and public ZSK are signed by the private KSK. This enables resolvers to use the public KSK to validate the public ZSK."
        ]
      },
      "Validation for resolvers now looks like this:",
      {
        "type": "list-numeric",
        "items": [
          "Request the desired <b>RRSet</b>, which also returns the corresponding <b>RRSIG</b> record.",
          "Request the DNSKEY records that contains <b>public ZSK and KSK</b> which also returns the <b>RRSig</b> for the <b>DNSKEY RRSet</b>.",
          "Verify the <b>RRSig</b> of the requested <b>RRSet</b> with the <b>public ZSK</b>.",
          "Verify the <b>RRSig</b> of the <b>DNSKEY RRSet</b> with the <b>public KSK</b>."
        ]
      },
      {
        "type": "picture",
        "width": "w60",
        "resource": "diagram-key-signing-keys-2.svg"
      },
      "You have probably already noticed the hierarchical nature of DNS, and this is just the beginning. Regarding KSK, the DNSKEY RRSet and corresponding RRSig records can be cached to avoid excessive requests to DNS name servers.",
      "The use of separate zone-signing keys and key-signing keys is aimed at facilitating the replacement of an old or compromised KSK, as we will discuss in the next section. Conversely, changing the ZSK is a simpler process, making it possible to use a smaller ZSK without compromising server security and reducing the amount of data that the server needs to transmit with each response.",
      "While we have established trust within our zone, DNS is a hierarchical system, and zones typically operate in conjunction with one another. The key-signing key is signed by itself, which doesn't add any extra trust, so we need a means of connecting the trust in our zone with its parent zone.",
      {
        "type": "list-bullet",
        "items": [
          "<b>DS Record - Delegation of Signing</b> — <b>a record containing the hash/digest of a child domain's/zone's public KSK (the fingerprint of child's public KSK)</b>. In DNSSEC, a delegation signer (DS) record is introduced to transfer trust from a parent zone to a child zone. To accomplish this, the zone operator hashes the public KSK contained in the DNSKEY record and provides it to the parent zone to publish as a DS record.\n\nWhenever a resolver is directed to a child zone, the parent zone also provides a DS record. This record enables resolvers to determine if the child zone is DNSSEC-enabled. To validate the public KSK of the zone, the resolver hashes it and compares it to the DS record from the parent zone. If the hash values match, the resolver can safely assume that the public KSK has not been compromised or altered, thereby establishing trust in all the records of the child zone. <b>This is how a chain of trust is established in DNSSEC.</b>"
        ]
      },
      {
        "type": "picture",
        "width": "w50",
        "resource": "diagram-delegation-signer-records.svg"
      },
      {
        "type": "list-bullet",
        "items": [
          "<b>The Chain of Trust</b> — the process of establishing trust within a zone and linking it to its parent zone, requires a mechanism for verifying the authenticity of the DS record. This is accomplished by digitally signing the DS record, similar to any other RRSet, resulting in the existence of a corresponding RRSig in the parent zone. The process of validating this signature is repeated successively, all the way up to the public KSK of the parent zone. To confirm the authenticity of this KSK, it is necessary to check the parent's DS record, continuing this process up the Chain of Trust."
        ]
      },
      {
        "type": "picture",
        "width": "w50",
        "resource": "diagram-the-chain-of-trust.svg"
      },
      {
        "type": "subtitle",
        "content": "DNSSEC Resolution Flow"
      },
      "Oh, that was tough, wasn't it? Okay, enough of this terminology, everything is better seen in examples. We are going to modify our previous DNS resolution flow to make it DNSSEC-enabled.",
      {
        "type": "list-numeric",
        "items": [
          "The client sends a recursive query to its local recursive caching DNS server for IP address of <b>\"cloudflare.com\"</b> webpage.",
          "The recursive caching DNS server sends an iterative query to a root (<b>\".\"</b>) nameserver for IP address of <b>\"cloudflare.com\"</b> webpage.",
          "The root nameserver:",
          [
            "Sends a referral:",
            {
              "style": "no-margin",
              "type": "list-bullet",
              "items": [
                "A non-secured referral for the authoritative TLD nameserver for the <b>\".com\"</b > zone"
              ]
            }
          ],
          "The recursive caching DNS server sends an iterative query to a <b>\".com\"</b> TLD nameserver for IP address of <b>\"cloudflare.com\"</b> webpage.",
          "The <b>\".com\"</b> TLD nameserver responds with a referral to <b>\"cloudflare\"</b> zone's authoritative nameserver.",
          "The recursive caching DNS server sends an iterative query to a <b>\"cloudflare\"</b> authoritative nameserver for IP address of <b>\"cloudflare.com\"</b> webpage.",
          "The <b>\"cloudflare\"</b> authoritative nameserver server responds with the IP address for <b>\"cloudflare.com\"</b>. webpage",
          "The recursive caching DNS server responds to the original client with the IP address of <b>\"cloudflare.com\"</b> (and caches it, if it had no this record).",
          "The client interacts with the web server <b>\"cloudflare.com\"</b>."
        ]
      },
      {
        "type": "title",
        "content": "The DNSSEC Root Signing Ceremony"
      },
      "Oh, in fact, in order to understand how everything works, you do not need to know anything about this ceremony, but it looks so cool and sounds so pathetic that I could not help but write about it. <b>Keys to the Internet</b>, not bad, huh?",
      {
        "type": "title",
        "content": "About DNS Encryption"
      },
      "As you have already found out, DNSSEC insures only authentication, but it still transfers it in plaintext. Here is where cryptography comes into play, our lovely HTTPS and TLS, which will help us to ensure not only authentication of our traffic, but also its confidentiality.",
      {
        "type": "subtitle",
        "content": "DNS over TLS"
      },
      "<b>DNS over TLS (or DoT)</b>, is a standard for encrypting DNS queries to keep them secure and private. DoT uses the same protocol as HTTPS to encrypt and authenticate connection. Normally, DNS works over UDP. What DoT does, it it adds TLS encryption on top of the user datagram protocol (UDP), which is used for DNS queries. Additionally, it ensures that DNS requests and responses are not tampered with or forged via on-path attacks.",
      {
        "type": "subtitle",
        "content": "DNS over HTTPS"
      },
      "<b>DNS over HTTPS (or DoH)</b> is an alternative way to DoT. DNS queries and responses are encrypted, but sent via the HTTP or HTTP/2 protocols instead of directly over UDP. DoH traffic looks like other HTTPS traffic - e.g. normal user-driven interactions with websites and web apps — from a network administrator's perspective.",
      "In February 2020, the Mozilla Firefox browser began enabling DoH for U.S. users by default. DNS queries from the Firefox browser are encrypted by DoH and go to either Cloudflare or NextDNS. Several other browsers also support DoH, although it is not turned on by default.",
      {
        "type": "subtitle",
        "content": "Difference between DoT and DoH"
      },
      "The main difference between them is <b>what port they use</b>. DoT only uses port 853, while DoH uses 443, which is the port that all other HTTPS traffic uses as well.",
      "Because DoT has a dedicated port, anyone with network visibility can see DoT traffic coming and going, even though the requests and responses themselves are encrypted. In contrast, with DoH, DNS queries and responses are camouflaged within other HTTPS traffic, since it all comes and goes from the same port.",
      "<b>From a network security standpoint, DoT is arguably better</b>. It gives network administrator the ability to monitor and block DNS queries, which is important for identifying and stopping malicious activity.",
      "<b>DoH queries, meanwhile, are hidden in regular HTTPS traffic</b>, meaning they cannot easily be blocked without blocking all other HTTPS traffic as well. However, from a privacy perspective, DoH is arguably preferable. With DoH, DNS queries are hidden within the larger flow of HTTPS traffic. This gives network administrators less visibility but provides users with more privacy.",
      {
        "type": "title",
        "content": "Conclusions"
      },
      "In conclusion, DNS (Domain Name System) is a fundamental component of the internet that is used to translate domain names into IP addresses. While DNS is critical for internet connectivity and online services, it is also vulnerable to a range of DNS-based attacks, including cache poisoning and DNS spoofing.",
      "To address these security concerns, DNSSEC (Domain Name System Security Extensions) has been developed as a security protocol that adds a layer of cryptographic security to the DNS system. By using digital signatures to verify the authenticity of DNS responses, DNSSEC can help to protect against a range of DNS-related attacks, ensuring the integrity and reliability of the DNS system.",
      "While the adoption of DNSSEC has been slow, it is becoming increasingly important as the threat of DNS-based attacks continues to grow. Organizations that rely on online services should consider implementing DNSSEC to protect their online presence, improve the security of their network, and reduce the risk of DNS-based attacks. As the internet continues to evolve, DNS and DNSSEC will remain essential components of the global network, ensuring the reliability and security of online services for years to come.",
      {
        "type": "title",
        "content": "Contact and references"
      }
    ],
    "references": [{
      "name": "What is DNS by Cloudflare",
      "link": "https://www.cloudflare.com/en-gb/learning/dns/what-is-dns/"
    }, {
      "name": "What is DNSSEC by Cloudflare (obvious, isn't it?)",
      "link": "https://www.cloudflare.com/en-gb/dns/dnssec/how-dnssec-works/"
    }, {
      "name": "DNS over TLS vs DNS over HTTPS",
      "link": "https://www.cloudflare.com/en-gb/learning/dns/dns-over-tls/"
    }, {
      "name": "DNS cache poisoning and spoofing",
      "link": "https://www.cloudflare.com/en-gb/learning/dns/dns-cache-poisoning/"
    }, {
      "name": "People who hold keys for the Internet",
      "link": "https://www.cloudflare.com/en-gb/dns/dnssec/root-signing-ceremony/"
    }, {
      "name": "Well-written article by ICANN about what DNSSEC is and why it is important",
      "link": "https://www.icann.org/resources/pages/dnssec-what-is-it-why-important-2019-03-05-en"
    }, {
      "name": "Really cool video that explains DNS and DNSSEC resolution flows",
      "link": "https://www.youtube.com/watch?v=_8M_vuFcdZU"
    }]
  }
}
