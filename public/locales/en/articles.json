{
  "nextjs-nginx-deployment": {
    "title": "NextJS Nginx Deployment",
    "tags": "nextjs,nginx,deployment,mikhail,bahdashych,mikhail bahdashych,blog",
    "description": "NextJS Nginx deployment process",
    "pageDescription": "The process of deployment is always quite stressful, especially if you are developer and kind of not familiar with what DevOps team is doing. Well, here is the easiest solution on how you can deploy your Next.js application using Nginx and Let's encrypt for HTTPS secure communication. Your cheatsheet.",
    "intro": "Oh God, you have no clue how I used to be scared of everything beyond writing code. I used to think that it's something unreal complicated and dangerous since your mistake can destroy literally everything, but then I tried, and you know, it sounds much scary then it is in really. The only thing you need to do is to start from the basics.",
    "timestamp": "2023-02-17",
    "footer": "That's all for today guys. Thanks for reading, I hope this was helpful and solved the problem you came across here looking for a solution.",
    "toc": {
      "intro": "Introduction",
      "whyNginx": "Why Nginx?",
      "preps": "Preparations",
      "HTTPS Configuration": {
        "certGen": "Certificate generating",
        "nginxSec": "Nginx security configuration"
      },
      "nginxConfig": "Nginx configuration",
      "appConfig": "Application setup using pm2",
      "conclusion": "Conclusions and cheatsheet",
      "references": "Contact and references"
    },
    "content": [
      {
        "type": "title",
        "content": "Introduction"
      },
      "The process of deployment of the application is always kind of stress, especially when you are a developer, who has no idea of what DevOps staff does (trust me, I know what I am talking about). Therefore, the only thing you really want is to as fast as possible deploy your application in a more or less secure way.",
      "Well, congratulations, you have come to the right place! This article will explain how you can deploy your Next.js application using Nginx in a secure manner and HTTPS encryption. So, let's start!",
      {
        "type": "title",
        "content": "Why Nginx?"
      },
      "Nginx (pronounced 'engine-x') is a high-performance, open-source web server. It is a reverse proxy server, which means it is designed to pass incoming requests from clients to other servers for further processing. This can be useful in a variety of situations, such as serving static files, proxying requests to a backend server, or handling SSL encryption.",
      "Nginx is known for its stability, robustness, and low resource usage, making it a popular choice for web administrators and hosting providers. It can handle a large number of concurrent connections, making it well-suited for high-traffic websites and web applications. It also has a wide range of features and configuration options, including load balancing, caching, and access control.",
      "In addition to its use as a web server, Nginx can also be used as a reverse proxy, load balancer, and HTTP cache. This versatility, combined with its performance and stability, has made Nginx a popular choice among web developers and system administrators.",
      "Overall, Nginx is a powerful and flexible web server that is well-suited for a wide range of applications and use cases. Whether you are serving a simple website, running a large web application, or anything in between, Nginx is a great choice for your needs.",
      {
        "type": "title",
        "content": "Preparations"
      },
      "We are not going to discuss how and where you can spin up an instance and harder it (either AWS, DigitalOcean, Microsoft Azure or whatever cloud service provider you like). By the way, you can read about this here (LINK TO POST ABOUT INSTANCES HARDERING). Instead of it, we will focus on process of installation of Nginx, as our web server, and Let's encrypt, as our CA provider, considering you already have an instance for deployment.",
      "Using next 2 commands you will update all packages on your machine and installed required nginx and Let's encrypt:",
      {
        "type": "code",
        "lang": "shell",
        "content": "$ sudo apt update && sudo apt upgrade\n$ sudo apt install nginx letsencrypt"
      },
      "Also enable nginx in ufw:",
      {
        "type": "code",
        "lang": "shell",
        "content": "$ sudo ufw allow 'Nginx Full'"
      },
      "Very last step here is checking if our nginx sever is working correctly. In order to do that go to <span class='code-block'>/etc/nginx/sites-available/default</span> and paste next content (<span class='code-block'>*q</span> is our domain):",
      {
        "type": "code",
        "lang": "bash",
        "content": "$ sudo vim /etc/nginx/sites-available/default"
      },
      {
        "type": "code",
        "lang": "nginx",
        "content": "server {\n\tlisten 80 default_server;\n\tlisten [::]:80 default_server;\n\n\troot /var/www/html;\n\tindex index.html index.htm index.nginx-debian.html;\n\n\tserver_name q*;\n\n\tlocation / {\n\t\ttry_files $uri $uri/ =404;\n\t}\n\n\t# letsencrypt\n\tlocation ~ /.well-known {\n\t\tallow all;\n\t}\n}"
      },
      "Check for syntax errors and restart nginx:",
      {
        "type": "code",
        "lang": "shell",
        "content": "$ sudo nginx -t\nnginx: the configuration file /etc/nginx/nginx.conf syntax is ok\nnginx: configuration file /etc/nginx/nginx.conf test is successful\n$ sudo systemctl restart nginx"
      },
      {
        "type": "title",
        "content": "HTTPS Configuration"
      },
      "Let's Encrypt is a free, open-source, and automated certificate authority (CA) that provides digital certificates for Transport Layer Security (TLS) encryption. These certificates are used to secure web traffic and ensure that sensitive information, such as passwords and credit card numbers, are transmitted securely over the internet.",
      "The main goal of Let's Encrypt is to make encryption more accessible to the general public by offering free and easy-to-use certificates. Prior to Let's Encrypt, obtaining a certificate could be a complicated and expensive process. With Let's Encrypt, anyone can obtain a certificate with just a few clicks, making it possible to secure a website or web application with minimal effort.",
      "Let's Encrypt is also notable for its automated certificate issuance and renewal process. This means that once you have obtained a certificate, you don't need to worry about manually renewing it in the future. The certificate will automatically renew itself as long as the domain remains active and under your control.",
      "In summary, Let's Encrypt is a game-changing CA that is making encryption more accessible and affordable for everyone. With its free and easy-to-use certificates, automated renewal process, and commitment to open-source software, Let's Encrypt is a great choice for anyone looking to secure their website or web application.",
      {
        "type": "subtitle",
        "content": "Certificate generating"
      },
      "It's time to generate some TLS certificates. In this example we are going to use Let's Encrypt, but you can use any other CA provider you want. As it was mentioned previously, replace <span class='code-block'>*q</span> by your domain name:",
      {
        "type": "code",
        "lang": "shell",
        "content": "$ sudo letsencrypt certonly -a webroot --webroot-path=/var/www/html -d *q"
      },
      "Next command will generated DH Parameters. These parameters define how OpenSSL performs the Diffie-Hellman (DH) key-exchange. Basically, additional layer of security for your HTTPS connection:",
      {
        "type": "code",
        "lang": "shell",
        "content": "$ sudo openssl dhparam -out /etc/ssl/certs/dhparam.pem 2048"
      },
      {
        "type": "subtitle",
        "content": "Nginx security configuration"
      },
      "The thing we need to do is to secure our Nginx server by putting next configuration to ssl-params.conf config file. By using your favorite text editor (vim here) copy and paste next content:",
      {
        "type": "code",
        "lang": "shell",
        "content": "$ sudo vim /etc/nginx/snippets/ssl-params.conf"
      },
      {
        "type": "code",
        "lang": "bash",
        "content": "ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\nssl_prefer_server_ciphers on;\nssl_ciphers \"EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH\";\nssl_ecdh_curvesecp384r1;\nssl_session_cache shared:SSL:10m;\nssl_session_tickets off;\nssl_stapling on;\nssl_stapling_verify on;\n\nresolver 8.8.8.8 8.8.4.4 valid=300s;\nresolver_timeout 5s;\n\nadd_header Strict-Transport-Security \"max-age=63072000;includeSubdomains\";\nadd_header X-Frame-Options DENY;\nadd_headerX-Content-Type-Options nosniff;\n\nssl_dhparam /etc/ssl/certs/dhparam.pem;"
      },
      {
        "type": "title",
        "content": "Nginx configuration"
      },
      "We are almost done with the configuration. The 2 very last things we need to do is to configure our Nginx server as a reverse proxy server and start application.",
      "Let's start with configuration out Nginx as a reverse proxy. Basically, here we need to edit out nginx file and paste next content (remember, <span class='code-block'>*q</span> is for your domain name):",
      {
        "type": "code",
        "lang": "bash",
        "content": "$ sudo vim /etc/nginx/sites-available/default"
      },
      {
        "type": "code",
        "lang": "nginx",
        "content": "# redirect http to https\nserver {\n\tlisten 80 default_server;\n\tlisten [::]:80 default_server;\n\tserver_name *q;\n\treturn 301 https://$server_name$request_uri;\n}\n\nserver {\n\t# listen on *:443 -> ssl; instead of *:80\n\tlisten 443 ssl http2 default_server;\n\tlisten [::]:443 ssl http2 default_server;\n\n\tserver_name q*;\n\n\tssl_certificate /etc/letsencrypt/live/*q/fullchain.pem;\n\tssl_certificate_key /etc/letsencrypt/live/*q/privkey.pem;\n\tinclude snippets/ssl-params.conf;\n\n\tlocation / {\n\t\t# reverse proxy for next server\n\n\t\t# It is important to mention that you need to change port\n\t\t# for application on port application uses when is started\n\t\t# after build.\n\t\tproxy_pass http://localhost:8080;\n\t\tproxy_http_version 1.1;\n\t\tproxy_set_header Upgrade $http_upgrade;\n\t\tproxy_set_header Connection 'upgrade';\n\t\tproxy_set_header Host $host;\n\t\tproxy_cache_bypass $http_upgrade;\n\n\t\t# we need to remove this 404 handling\n\t\t# because next's _next folder and own handling\n\t\t# try_files $uri $uri/ =404;\n\t}\n\n\tlocation ~ /.well-known {\n\t\tallow all;\n\t}\n}"
      },
      "Restart the nginx service and the only thing we need to do is to set up our application as a daemon using pm2 process manager:",
      {
        "type": "code",
        "lang": "shell",
        "content": "$ sudo service nginx restart"
      },
      {
        "type": "title",
        "content": "Application setup using pm2"
      },
      "PM2 is a production process manager for Node.js applications. It is designed to keep your Node.js applications running and be able to recover from unexpected errors or crashes. PM2 provides features such as automatic restart, automatic log management, and process monitoring.",
      "PM2 makes it easy to run Node.js applications in the background as a daemon, without having to worry about the process being terminated or restarted. This is particularly useful for long-running Node.js applications, such as web servers or background workers, as it ensures that they are always available and can recover from any issues that may arise.",
      "In addition to its process management features, PM2 also provides powerful process monitoring capabilities. This includes detailed information about the status and performance of your Node.js applications, such as CPU and memory usage, as well as the ability to manage and inspect log files.",
      "PM2 is a popular tool for managing Node.js applications in production environments, as it makes it easy to keep your applications running and provides a wealth of information about their status and performance. Whether you are running a single Node.js application or multiple applications in a cluster, PM2 is a great tool for managing and monitoring your applications.",
      "Basically, here, we need to just build our application, install pm2 application globally and start the process of executed production build as a daemon in the background:",
      {
        "type": "code",
        "lang": "shell",
        "content": "$ npm run build # build our app for production (npm build script: next build)\n$ npm i -g pm2 # install pm2 to keep next app alive forever*\n$ pm2 start npm --name \"next\" -- start # start next app (npm start script: next start)\n"
      },
      "Enjoy your application in production mode and secured HTTPS connection! Below you will also find a couple afterwords and small guidebook on how you can manage your application using this process manager.",
      {
        "type": "title",
        "content": "Conclusions and cheatsheet"
      },
      "Was quite easy, huh? This is the easiest way to configure, deploy and secure your Next.js application using Nginx. But maybe you have a question like: \"Okay, that's fine, but what about CI/CD pipeline?\". Well, that is on yours. You can either configure it using GitHub Actions or Jenkins or whatever CI/CD pipeline tool you prefer. But if you want to know, how you can do deployment manually, here you go.",
      "The very first thing you need to do is to go to your server and go to folder with your project. There, pull the master (main) branch or whatever branch you use in production mode, install all packages, build the project (using npm in this particular example) and restart the pm2 process:",
      {
        "type": "code",
        "lang": "shell",
        "content": "$ git pull origin master\n$ npm i\n$ npm run build\n$ pm2 restart blog"
      },
      "By the way, I guess you want to change the name of the application on something more human-readable. Here is how you can do that. First of all type next command to get list of all processes handled by pm2:",
      {
        "type": "code",
        "lang": "shell",
        "content": "$ pm2 list"
      },
      "As a result you will see pretty looking table, take a look at the id column, at this moment, I guess, you will see 0 value, but if not, just replace it on your value and type next to change the name of the process:",
      {
        "type": "code",
        "lang": "shell",
        "content": "$ pm2 restart 0 --name \"new-name\""
      },
      "You are awesome! Cheatsheet specially for you:",
      {
        "type": "code",
        "lang": "bash",
        "content": "# Update and upgrade all packages and install required programs\n$ sudo apt update && sudo apt upgrade\n$ sudo apt install nginx letsencrypt"
      },
      {
        "type": "code",
        "lang": "bash",
        "content": "# Also enable nginx in ufw\n$ sudo ufw allow 'Nginx Full'"
      },
      {
        "type": "code",
        "lang": "bash",
        "content": "# Paste next content in sites-available/default file and test the server\n$ sudo vim /etc/nginx/sites-available/default"
      },
      {
        "type": "code",
        "lang": "nginx",
        "content": "# Replace *q with your domain name\nserver {\n\tlisten 80 default_server;\n\tlisten [::]:80 default_server;\n\n\troot /var/www/html;\n\tindex index.html index.htm index.nginx-debian.html;\n\n\tserver_name q*;\n\n\tlocation / {\n\t\ttry_files $uri $uri/ =404;\n\t}\n\n\t# letsencrypt\n\tlocation ~ /.well-known {\n\t\tallow all;\n\t}\n}"
      },
      {
        "type": "code",
        "lang": "bash",
        "content": "# Check for syntax error and restart the server\n$ sudo nginx -t\nnginx: the configuration file /etc/nginx/nginx.conf syntax is ok\nnginx: configuration file /etc/nginx/nginx.conf test is successful\n$ sudo systemctl restart nginx"
      },
      {
        "type": "code",
        "lang": "bash",
        "content": "# Generate the TLS certificate (replace *q with your domain name)\n$ sudo letsencrypt certonly -a webroot --webroot-path=/var/www/html -d *q"
      },
      {
        "type": "code",
        "lang": "bash",
        "content": "# Generate Diffie-Hellman (DH) params\n$ sudo openssl dhparam -out /etc/ssl/certs/dhparam.pem 2048"
      },
      {
        "type": "code",
        "lang": "bash",
        "content": "# Secure our Nginx server by pasting next into config file\n$ sudo vim /etc/nginx/snippets/ssl-params.conf"
      },
      {
        "type": "code",
        "lang": "bash",
        "content": "ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\nssl_prefer_server_ciphers on;\nssl_ciphers \"EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH\";\nssl_ecdh_curvesecp384r1;\nssl_session_cache shared:SSL:10m;\nssl_session_tickets off;\nssl_stapling on;\nssl_stapling_verify on;\n\nresolver 8.8.8.8 8.8.4.4 valid=300s;\nresolver_timeout 5s;\n\nadd_header Strict-Transport-Security \"max-age=63072000;includeSubdomains\";\nadd_header X-Frame-Options DENY;\nadd_headerX-Content-Type-Options nosniff;\n\nssl_dhparam /etc/ssl/certs/dhparam.pem;"
      },
      {
        "type": "code",
        "lang": "bash",
        "content": "# Paste next config into file\n# Remember about port of localhost and replacing *q with domain name\n$ sudo vim /etc/nginx/sites-available/default"
      },
      {
        "type": "code",
        "lang": "nginx",
        "content": "# redirect http to https\nserver {\n\tlisten 80 default_server;\n\tlisten [::]:80 default_server;\n\tserver_name *q;\n\treturn 301 https://$server_name$request_uri;\n}\n\nserver {\n\t# listen on *:443 -> ssl; instead of *:80\n\tlisten 443 ssl http2 default_server;\n\tlisten [::]:443 ssl http2 default_server;\n\n\tserver_name q*;\n\n\tssl_certificate /etc/letsencrypt/live/*q/fullchain.pem;\n\tssl_certificate_key /etc/letsencrypt/live/*q/privkey.pem;\n\tinclude snippets/ssl-params.conf;\n\n\tlocation / {\n\t\t# reverse proxy for next server\n\n\t\t# It is important to mention that you need to change port\n\t\t# for application on port application uses when is started\n\t\t# after build.\n\t\tproxy_pass http://localhost:8080;\n\t\tproxy_http_version 1.1;\n\t\tproxy_set_header Upgrade $http_upgrade;\n\t\tproxy_set_header Connection 'upgrade';\n\t\tproxy_set_header Host $host;\n\t\tproxy_cache_bypass $http_upgrade;\n\n\t\t# we need to remove this 404 handling\n\t\t# because next's _next folder and own handling\n\t\t# try_files $uri $uri/ =404;\n\t}\n\n\tlocation ~ /.well-known {\n\t\tallow all;\n\t}\n}"
      },
      {
        "type": "code",
        "lang": "bash",
        "content": "# Restart the service\n$ sudo service nginx restart"
      },
      {
        "type": "code",
        "lang": "shell",
        "content": "# Build and start the application\n$ npm run build # build our app for production (npm build script: next build)\n$ npm i -g pm2 # install pm2 to keep next app alive forever*\n$ pm2 start npm --name \"next\" -- start # start next app (npm start script: next start)\n"
      },
      {
        "type": "title",
        "content": "Contact and references"
      }
    ],
    "references": [{
      "name": "The original GitHub gist",
      "link": "https://gist.github.com/jjsquady/5399d6e1b23f501083a9c262d806e248"
    }]
  },
  "everything-you-need-to-know-about-hardening": {
    "title": "Everything you need to know about hardening",
    "tags": "",
    "description": "",
    "pageDescription": "Instance hardening refers to the process of securing an instance, which is a single occurrence of a virtual or physical machine that is running an operating system and hosting applications or services. The objective of instance hardening is to minimize the risk of unauthorized access to the instance, protect the data and applications hosted on it, and prevent any compromise of the system.",
    "intro": "",
    "timestamp": "",
    "footer": "",
    "toc": {
      "intro": "Introduction"
    },
    "content": {}
  },
  "pki-infrastructure-or-how-to-build-your-own-vpn": {
    "title": "PKI infrastructure or how to build your own VPN",
    "tags": "",
    "description": "",
    "pageDescription": "Have you ever thought about how VPN works? I think that this technology has become so much part of the modern business and all its infrastructure that we do not even think about it. And it would be worth it! Today we will discuss how we can build our infrastructure of VPN and generally find out how it all works.",
    "intro": "",
    "timestamp": "",
    "footer": "",
    "toc": {
      "intro": "Introduction"
    },
    "content": {}
  },
  "how-does-dns-work-and-why-we-need-dnssec": {
    "title": "How does DNS work and why we need DNSSEC",
    "tags": "mikhail,bahdashych,mikhail bahdashych,blog,dns,dnssec",
    "description": "Have you ever heard about DNS? I bet you have! Also I bet that if you tried to figure out what this is all about you have seen DNSSEC. Well... it's time to figure out how deep this rabbit hole actually is...",
    "pageDescription": "I guess all you guys have ever heard about DNS. This is phone book of the Internet, and it converts human-readable domain names into IP addresses parsed by machines and blah-blah-blah. Honestly, this is literally rabbit hole, and I have decided to figure out how deep it is. Well, trust me, you are going to be surprised and I have hella interesting stuff to share with you. So, let's dive into it!",
    "intro": "",
    "timestamp": "",
    "footer": "Pew... That was kinda complicated, wasn't it? But now you what DNS and DNSSEC actually are and how they work. If after reading you have even more questions than before, congratulations, from now on you will be able to find all answers on your own, but that's it for now. Thank you so much for reading.",
    "toc": {
      "intro": "Introduction",
      "DNS Overview": {
        "terminology": "DNS Terminology",
        "resolutionFlow": "DNS Resolution Flow",
        "dnsRoles": "DNS Servers Roles",
        "recordsTypes": "DNS Records Types"
      },
      "dnssecIntro": "Introduction into DNSSEC",
      "DNSSEC Overview": {
        "terminology": "DNSSEC Terminology",
        "resolutionFlow": "DNSSEC Resolution Flow"
      },
      "conclusion": "Conclusions",
      "references": "Contact and references"
    },
    "content": [
      {
        "type": "title",
        "content": "Introduction"
      },
      "In today's digital age, the Domain Name System (DNS) plays a vital role in facilitating online communication and enabling users to access websites and services on the internet. However, with the increasing number of cybersecurity threats and malicious activities, there is a growing concern about the security of DNS and the potential risks associated with it.",
      "This is where DNS Security Extensions (DNSSEC) comes into the picture, offering a powerful solution to strengthen the security of DNS and protect against various attacks such as DNS spoofing, cache poisoning, and other forms of cyber threats.",
      "In this blog post, we'll take a closer look at what DNS and DNSSEC are, how they work, and why they are essential for maintaining a secure and reliable internet infrastructure. We'll also explore some real-world use cases and discuss the benefits and limitations of DNSSEC. So, if you want to learn more about DNS and DNSSEC and how they can help secure your online presence, keep reading!",
      {
        "type": "title",
        "content": "DNS Overview"
      },
      "The same as always let's start with short description what DNS actually is and how it can be described. The most popular definition of DNS always sounds more or less like that:",
      {
        "type": "list",
        "items": ["<b>DNS (Domain Name System)</b> - system that translates human-readable domain names to IP address, so machines can communicate with each other using those IP addresses."]
      },
      "Sounds pretty common, isn't it? I wanted to try to dig a little deeper in order to find out what happens after you write URL address into your browser and hit Enter button. I wanted to know what is happening behind the scene and how your computer obtains the IP address of source web server.",
      {
        "type": "subtitle",
        "content": "DNS Terminology"
      },
      "But before we start, let's define some terminology we are going to use all through our long journey. Feel free to get back to them whenever you need that:",
      {
        "type": "list-bullet",
        "items": [
          "<b>DNS Domain / DNS Zone</b> - a section of the DNS namespace. For instance: blog.mikhailbahdashych.me. (trailing dot is not a typo) is the server named \"blog\" in the \"mikhailbahdashych\" domain/zone, which is in the \"me\" domain/zone, which is in the \"root (.)\" domain/zone.",
          "<b>Iterative DNS Query</b> - a request to a DNS server: 'Give me whatever help you can, but ask no one else'.",
          "<b>Recursive DNS Query</b> - a request to a DNS server: 'Give me what I need, and ask everyone you want'.",
          "<b>DNS Server</b> - term that described the whole infrastructure of DNS roles. It's okay, if you don't understand it at this point, we will clarify that."
        ]
      },
      {
        "type": "subtitle",
        "content": "DNS Resolution Flow"
      },
      "The very first thing we need to know about is: how does your browser send some text in form of URL and get back IP address of requested website? At this moment of time we are discussing DNS only from perspective that the only thing it does is converting URLs into IP address of websites, but we will expand its usage a little later.",
      "Here is where <b>DNS Resolution Flow</b> comes into play. Everything is better on examples, so let's say you want to request for <b>cloudflare.com</b>. Here is what is happening after you paste URL in browser and hit Enter button:",
      {
        "type": "list-numeric",
        "items": [
          "<b>DNS Stub Resolver</b> - everything starts with DNS stub resolver or DNS Client.",
          "<b>DNS Recursive Resolver</b> - ",
          "<b>DNS Root Nameserver</b> -",
          "<b>DNS TLD Nameserver</b> -",
          "<b>Authoritative Nameserver</b> -"
        ]
      },
      {
        "type": "picture",
        "resource": "dns_record_request_sequence_recursive_resolver.png"
      },
      {
        "type": "picture",
        "resource": "what_is_a_dns_server_dns_lookup.png"
      },
      {
        "type": "subtitle",
        "content": "DNS Servers Roles"
      },
      {
        "type": "subtitle",
        "content": "DNS Records Types"
      },
      {
        "type": "title",
        "content": "Introduction into DNSSEC"
      },
      {
        "type": "title",
        "content": "DNSSEC Overview"
      },
      {
        "type": "subtitle",
        "content": "DNSSEC Terminology"
      },
      {
        "type": "subtitle",
        "content": "DNSSEC Resolution Flow"
      },
      {
        "type": "title",
        "content": "Conclusions"
      },
      {
        "type": "title",
        "content": "Contact and references"
      }
    ],
    "references": [{
      "name": "What is DNS by Cloudflare",
      "link": "https://www.cloudflare.com/en-gb/learning/dns/what-is-dns/"
    }, {
      "name": "What is DNSSEC by Cloudflare (obvious, isn't it?)",
      "link": "https://www.cloudflare.com/en-gb/dns/dnssec/how-dnssec-works/"
    }, {
      "name": "Really cool video that explains DNS and DNSSEC resolution flows",
      "link": "https://www.youtube.com/watch?v=_8M_vuFcdZU"
    }]
  }
}
