{
  "nextjs-nginx-deployment": {
    "title": "NextJS Nginx Deployment",
    "tags": "nextjs,nginx,deployment,mikhail,bahdashych,mikhail bahdashych,blog",
    "description": "NextJS Nginx deployment process",
    "pageDescription": "Процесс развертывания всегда довольно напряженный, особенно если вы разработчик и не знакомы с тем, чем занимается команда DevOps. Что ж, вот самое простое решение о том, как вы можете развернуть свое приложение Next.js, используя Nginx и Letsencrypt для безопасной связи HTTPS. Ваша шпаргалка.",
    "intro": "О Боже, ты не представляешь, как раньше я боялся всего, кроме написания кода. Раньше я думал, что это что-то нереальное законченное и опасное, так как твоя ошибка может разрушить буквально все, но потом я попробовал, и знаешь, звучит намного страшнее, чем на самом деле. Единственное, что вам нужно сделать, это начать с основ.",
    "timestamp": "2023-02-17",
    "footer": "Это все на сегодня, ребята. Спасибо за прочтение, надеюсь это было полезно и решило проблему, в поисках решения которой вы набрели сюда.",
    "toc": {
      "intro": "Интро",
      "whyNginx": "Почему Nginx?",
      "preps": "Подготовка",
      "Конфигурация HTTPS": {
        "certGen": "Создание сертификата",
        "nginxSec": "Конфигурация безопасности Nginx"
      },
      "nginxConfig": "Конфигурация Nginx",
      "appConfig": "Настройка приложения с помощью pm2",
      "conclusion": "Выводы и шпаргалка",
      "references": "Контакт и ссылки"
    },
    "content": {
      "p0": {
        "type": "title",
        "content": "Интро"
      },
      "p1": "Процесс развертывания приложения — это всегда стресс, особенно когда ты разработчик, который понятия не имеет, чем занимается DevOps-персонал (поверьте, я знаю, о чем говорю). Поэтому единственное, чего вы действительно хотите, — это как можно быстрее развернуть ваше приложение более или менее безопасным способом.",
      "p2": "Что ж, поздравляем, вы попали по адресу! В этой статье объясняется, как безопасно развернуть приложение Next.js с помощью Nginx и шифрования HTTPS. Итак, начнем!",
      "p3": {
        "type": "title",
        "content": "Почему Nginx?"
      },
      "p4": "Nginx (произносится как 'engine-x') — это высокопроизводительный веб-сервер с открытым исходным кодом. Это обратный прокси-сервер, что означает, что он предназначен для передачи входящих запросов от клиентов на другие серверы для дальнейшей обработки. Это может быть полезно в различных ситуациях, таких как обслуживание статических файлов, проксирование запросов на внутренний сервер или обработка SSL-шифрования.",
      "p5": "Nginx известен своей стабильностью, надежностью и низким потреблением ресурсов, что делает его популярным выбором для веб-администраторов и хостинг-провайдеров. Он может обрабатывать большое количество одновременных подключений, что делает его подходящим для веб-сайтов и веб-приложений с высокой посещаемостью. Он также имеет широкий спектр функций и параметров конфигурации, включая балансировку нагрузки, кэширование и контроль доступа.",
      "p6": "Помимо использования в качестве веб-сервера, Nginx также можно использовать в качестве обратного прокси-сервера, балансировщика нагрузки и кэша HTTP. Эта универсальность в сочетании с производительностью и стабильностью сделала Nginx популярным выбором среди веб-разработчиков и системных администраторов.",
      "p7": "В целом, Nginx — это мощный и гибкий веб-сервер, который хорошо подходит для широкого спектра приложений и вариантов использования. Независимо от того, обслуживаете ли вы простой веб-сайт, запускаете большое веб-приложение или что-то среднее, Nginx — отличный выбор для ваших нужд.",
      "p8": {
        "type": "title",
        "content": "Подготовка"
      },
      "p9": "Мы не будем обсуждать, как и где можно раскрутить инстанс и усложнить его (будь то AWS, DigitalOcean, Microsoft Azure или любой другой поставщик облачных услуг, который вам нравится). Кстати, об этом можно прочитать здесь (ССЫЛКА НА ПОСТ О ИНСТАНЦИЯХ ХАРДЕРИНГА). Вместо этого мы сосредоточимся на процессе установки Nginx в качестве нашего веб-сервера и Letsencrypt в качестве нашего поставщика ЦС, учитывая, что у вас уже есть экземпляр для развертывания.",
      "p10": "Используя следующие 2 команды, вы обновите все пакеты на своем компьютере и установите необходимые nginx и Letsencrypt:",
      "p11": {
        "type": "code",
        "lang": "shell",
        "content": "$ sudo apt update && sudo apt upgrade\n$ sudo apt install nginx letsencrypt"
      },
      "p12": "Also enable nginx in ufw:",
      "p13": {
        "type": "code",
        "lang": "shell",
        "content": "$ sudo ufw allow 'Nginx Full'"
      },
      "p14": "Самый последний шаг здесь — проверка правильности работы нашего сервера nginx. Для этого перейдите в <span class='code-block'>/etc/nginx/sites-available/default</span> и вставьте следующее содержимое (<span class='code-block'>*q</span> — это наш домен)",
      "p15": {
        "type": "code",
        "lang": "bash",
        "content": "$ sudo vim /etc/nginx/sites-available/default"
      },
      "p16": {
        "type": "code",
        "lang": "nginx",
        "content": "server {\n\tlisten 80 default_server;\n\tlisten [::]:80 default_server;\n\n\troot /var/www/html;\n\tindex index.html index.htm index.nginx-debian.html;\n\n\tserver_name q*;\n\n\tlocation / {\n\t\ttry_files $uri $uri/ =404;\n\t}\n\n\t# letsencrypt\n\tlocation ~ /.well-known {\n\t\tallow all;\n\t}\n}"
      },
      "p17": "Проверьте синтаксические ошибки и перезапустите nginx:",
      "p18": {
        "type": "code",
        "lang": "shell",
        "content": "$ sudo nginx -t\nnginx: the configuration file /etc/nginx/nginx.conf syntax is ok\nnginx: configuration file /etc/nginx/nginx.conf test is successful\n$ sudo systemctl restart nginx"
      },
      "p19": {
        "type": "title",
        "content": "Конфигурация HTTPS"
      },
      "p20": "Let's Encrypt — это бесплатный автоматизированный центр сертификации (ЦС) с открытым исходным кодом, который предоставляет цифровые сертификаты для шифрования TLS. Эти сертификаты используются для защиты веб-трафика и обеспечения безопасной передачи конфиденциальной информации, такой как пароли и номера кредитных карт, через Интернет.",
      "p21": "Основная цель Let’s Encrypt — сделать шифрование более доступным для широкой публики, предлагая бесплатные и простые в использовании сертификаты. До Let's Encrypt получение сертификата могло быть сложным и дорогостоящим процессом. С Let's Encrypt каждый может получить сертификат всего за несколько кликов, что позволяет защитить веб-сайт или веб-приложение с минимальными усилиями.",
      "p22": "Let's Encrypt также отличается автоматизированным процессом выпуска и обновления сертификатов. Это означает, что после получения сертификата вам не нужно беспокоиться о его ручном продлении в будущем. Сертификат будет автоматически обновляться до тех пор, пока домен остается активным и находится под вашим контролем.",
      "p23": "Таким образом, Let's Encrypt — это центр сертификации, который меняет правила игры и делает шифрование более доступным для всех. Благодаря бесплатным и простым в использовании сертификатам, автоматизированному процессу обновления и приверженности программному обеспечению с открытым исходным кодом Let's Encrypt является отличным выбором для всех, кто хочет защитить свой веб-сайт или веб-приложение.",
      "p24": {
        "type": "subtitle",
        "content": "Создание сертификата"
      },
      "p25": "Пришло время сгенерировать несколько сертификатов TLS. В этом примере мы собираемся использовать Let's Encrypt, но вы можете использовать любого другого провайдера ЦС. Как упоминалось ранее, замените <span class='code-block'>*q</span> на имя вашего домена:",
      "p26": {
        "type": "code",
        "lang": "shell",
        "content": "$ sudo letsencrypt certonly -a webroot --webroot-path=/var/www/html -d *q"
      },
      "p27": "Следующая команда сгенерирует параметры DH. Эти параметры определяют, как OpenSSL выполняет обмен ключами Диффи-Хеллмана (DH). По сути, дополнительный уровень безопасности для вашего HTTPS-соединения:",
      "p28": {
        "type": "code",
        "lang": "shell",
        "content": "$ sudo openssl dhparam -out /etc/ssl/certs/dhparam.pem 2048"
      },
      "p29": {
        "type": "subtitle",
        "content": "Конфигурация безопасности Nginx"
      },
      "p30": "Нам нужно защитить наш сервер Nginx, поместив следующую конфигурацию в файл конфигурации ssl-params.conf. С помощью вашего любимого текстового редактора (здесь vim) скопируйте и вставьте следующее содержимое:",
      "p31": {
        "type": "code",
        "lang": "shell",
        "content": "$ sudo vim /etc/nginx/snippets/ssl-params.conf"
      },
      "p32": {
        "type": "code",
        "lang": "bash",
        "content": "ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\nssl_prefer_server_ciphers on;\nssl_ciphers \"EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH\";\nssl_ecdh_curvesecp384r1;\nssl_session_cache shared:SSL:10m;\nssl_session_tickets off;\nssl_stapling on;\nssl_stapling_verify on;\n\nresolver 8.8.8.8 8.8.4.4 valid=300s;\nresolver_timeout 5s;\n\nadd_header Strict-Transport-Security \"max-age=63072000;includeSubdomains\";\nadd_header X-Frame-Options DENY;\nadd_headerX-Content-Type-Options nosniff;\n\nssl_dhparam /etc/ssl/certs/dhparam.pem;"
      },
      "p33": {
        "type": "title",
        "content": "Конфигурация Nginx"
      },
      "p34": "Мы почти закончили настройку. Две самые последние вещи, которые нам нужно сделать, это настроить наш сервер Nginx в качестве обратного прокси-сервера и запустить приложение.",
      "p35": "Начнем с настройки Nginx в качестве обратного прокси. По сути, здесь нам нужно отредактировать файл nginx и вставить следующее содержимое (помните, что <span class='code-block'>*q</span> соответствует вашему доменному имени):",
      "p36": {
        "type": "code",
        "lang": "bash",
        "content": "$ sudo vim /etc/nginx/sites-available/default"
      },
      "p37": {
        "type": "code",
        "lang": "nginx",
        "content": "# http на https\nserver {\n\tlisten 80 default_server;\n\tlisten [::]:80 default_server;\n\tserver_name *q;\n\treturn 301 https://$server_name$request_uri;\n}\n\nserver {\n\t# listen on *:443 -> ssl; instead of *:80\n\tlisten 443 ssl http2 default_server;\n\tlisten [::]:443 ssl http2 default_server;\n\n\tserver_name q*;\n\n\tssl_certificate /etc/letsencrypt/live/*q/fullchain.pem;\n\tssl_certificate_key /etc/letsencrypt/live/*q/privkey.pem;\n\tinclude snippets/ssl-params.conf;\n\n\tlocation / {\n\t\t# обратный прокси для next сервера\n\n\t\t# Важно отметить, что вам нужно изменить порт\n\t\t# для приложения на порт, которое приложение использует при запуске\n\t\t# после сборки.\n\t\tproxy_pass http://localhost:8080;\n\t\tproxy_http_version 1.1;\n\t\tproxy_set_header Upgrade $http_upgrade;\n\t\tproxy_set_header Connection 'upgrade';\n\t\tproxy_set_header Host $host;\n\t\tproxy_cache_bypass $http_upgrade;\n\n\t\t# нам нужно удалить эту обработку 404\n\t\t# потому что папка _next и собственная обработка\n\t\t# try_files $uri $uri/ =404;\n\t}\n\n\tlocation ~ /.well-known {\n\t\tallow all;\n\t}\n}"
      },
      "p38": "Перезапустите службу nginx, и единственное, что нам нужно сделать, это настроить наше приложение как демон с помощью диспетчера процессов pm2:",
      "p39": {
        "type": "code",
        "lang": "shell",
        "content": "$ sudo service nginx restart"
      },
      "p40": {
        "type": "title",
        "content": "Настройка приложения с помощью pm2"
      },
      "p41": "PM2 — это менеджер производственных процессов для приложений Node.js. Он предназначен для поддержания работоспособности ваших приложений Node.js и возможности восстановления после непредвиденных ошибок или сбоев. PM2 предоставляет такие функции, как автоматический перезапуск, автоматическое управление журналом и мониторинг процессов.",
      "p42": "PM2 позволяет легко запускать приложения Node.js в фоновом режиме в качестве демона, не беспокоясь о завершении или перезапуске процесса. Это особенно полезно для долго работающих приложений Node.js, таких как веб-серверы или фоновые рабочие процессы, поскольку гарантирует их постоянную доступность и возможность восстановления после любых проблем, которые могут возникнуть.",
      "p43": "Помимо функций управления процессами, PM2 также предоставляет мощные возможности мониторинга процессов. Сюда входит подробная информация о состоянии и производительности ваших приложений Node.js, например об использовании ЦП и памяти, а также возможность управлять файлами журналов и проверять их.",
      "p44": "PM2 — это популярный инструмент для управления приложениями Node.js в производственных средах, поскольку он упрощает поддержание работоспособности ваших приложений и предоставляет обширную информацию об их состоянии и производительности. Независимо от того, используете ли вы одно приложение Node.js или несколько приложений в кластере, PM2 — отличный инструмент для управления и мониторинга ваших приложений.",
      "p45": "По сути, здесь нам нужно просто собрать наше приложение, глобально установить приложение pm2 и запустить процесс выполнения рабочей сборки в качестве демона в фоновом режиме:",
      "p46": {
        "type": "code",
        "lang": "shell",
        "content": "$ npm run build # сборка приложения (npm build script: next build)\n$ npm i -g pm2 # установите pm2, чтобы следующее приложение всегда оставалось в работе*\n$ pm2 start npm --name \"next\" -- start # старт приложения (npm start script: next start)\n"
      },
      "p47": "Наслаждайтесь своим приложением в рабочем режиме и защищенным HTTPS-соединением! Ниже вы также найдете пару послесловий и небольшое руководство о том, как вы можете управлять своим приложением с помощью этого диспетчера процессов.",
      "p48": {
        "type": "title",
        "content": "Выводы и шпаргалка"
      },
      "p49": "Было довольно легко, да? Это самый простой способ настроить, развернуть и защитить ваше приложение Next.js с помощью Nginx. Но, возможно, у вас возникнет вопрос типа: \"Хорошо, это хорошо, но как насчет конвейера CI/CD?\". Ну это на твоем. Вы можете настроить его с помощью GitHub Actions, Jenkins или любого другого инструмента конвейера CI/CD, который вы предпочитаете. Но если вы хотите узнать, как выполнить развертывание вручную, то вам сюда.",
      "p50": "Самое первое, что вам нужно сделать, это зайти на свой сервер и перейти в папку с вашим проектом. Там обновите master (main) ветку или любую другую ветку, которую вы используете в рабочем режиме, установите все пакеты, соберите проект (используя npm в этом конкретном примере) и перезапустите процесс pm2.:",
      "p51": {
        "type": "code",
        "lang": "shell",
        "content": "$ git pull origin master\n$ npm i\n$ npm run build\n$ pm2 restart blog"
      },
      "p52": "Кстати, я думаю, вы хотите изменить название приложения на что-то более понятное для человека. Вот как вы можете это сделать. Прежде всего введите следующую команду, чтобы получить список всех процессов, обрабатываемых pm2:",
      "p53": {
        "type": "code",
        "lang": "shell",
        "content": "$ pm2 list"
      },
      "p54": "В результате вы увидите красивую таблицу, взгляните на столбец id, в этот момент, я думаю, вы увидите значение 0, но если нет, просто замените его на свое значение и введите рядом, чтобы изменить имя процесс:",
      "p55": {
        "type": "code",
        "lang": "shell",
        "content": "$ pm2 restart 0 --name \"new-name\""
      },
      "p56": "Ты обалденный! Шпаргалка специально для вас:",
      "p57": {
        "type": "code",
        "lang": "bash",
        "content": "# Обновите и обновите все пакеты и установите необходимые программы\n$ sudo apt update && sudo apt upgrade\n$ sudo apt install nginx letsencrypt"
      },
      "p58": {
        "type": "code",
        "lang": "bash",
        "content": "# Также включите nginx в ufw\n$ sudo ufw allow 'Nginx Full'"
      },
      "p59": {
        "type": "code",
        "lang": "bash",
        "content": "# Вставьте следующее содержимое в файл sites-available/default, и проверьте сервер\n$ sudo vim /etc/nginx/sites-available/default"
      },
      "p60": {
        "type": "code",
        "lang": "nginx",
        "content": "# Замените *q на ваше доменное имя\nserver {\n\tlisten 80 default_server;\n\tlisten [::]:80 default_server;\n\n\troot /var/www/html;\n\tindex index.html index.htm index.nginx-debian.html;\n\n\tserver_name q*;\n\n\tlocation / {\n\t\ttry_files $uri $uri/ =404;\n\t}\n\n\t# letsencrypt\n\tlocation ~ /.well-known {\n\t\tallow all;\n\t}\n}"
      },
      "p61": {
        "type": "code",
        "lang": "bash",
        "content": "# Проверьте синтаксические ошибкт и перезапустите сервер\n$ sudo nginx -t\nnginx: the configuration file /etc/nginx/nginx.conf syntax is ok\nnginx: configuration file /etc/nginx/nginx.conf test is successful\n$ sudo systemctl restart nginx"
      },
      "p62": {
        "type": "code",
        "lang": "bash",
        "content": "# Создайте сертификат TLS (замените *q на ваше доменное имя)\n$ sudo letsencrypt certonly -a webroot --webroot-path=/var/www/html -d *q"
      },
      "p63": {
        "type": "code",
        "lang": "bash",
        "content": "# Генерация параметров Диффи-Хеллмана (DH)\n$ sudo openssl dhparam -out /etc/ssl/certs/dhparam.pem 2048"
      },
      "p64": {
        "type": "code",
        "lang": "bash",
        "content": "# Защитите сервер Nginx, вставив следующий в файл конфигурации\n$ sudo vim /etc/nginx/snippets/ssl-params.conf"
      },
      "p65": {
        "type": "code",
        "lang": "bash",
        "content": "ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\nssl_prefer_server_ciphers on;\nssl_ciphers \"EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH\";\nssl_ecdh_curvesecp384r1;\nssl_session_cache shared:SSL:10m;\nssl_session_tickets off;\nssl_stapling on;\nssl_stapling_verify on;\n\nresolver 8.8.8.8 8.8.4.4 valid=300s;\nresolver_timeout 5s;\n\nadd_header Strict-Transport-Security \"max-age=63072000;includeSubdomains\";\nadd_header X-Frame-Options DENY;\nadd_headerX-Content-Type-Options nosniff;\n\nssl_dhparam /etc/ssl/certs/dhparam.pem;"
      },
      "p66": {
        "type": "code",
        "lang": "bash",
        "content": "# Вставить следующий конфиг в файл\n# Помните о порте localhost и замене *q на доменное имя\n$ sudo vim /etc/nginx/sites-available/default"
      },
      "p67": {
        "type": "code",
        "lang": "nginx",
        "content": "# http на https\nserver {\n\tlisten 80 default_server;\n\tlisten [::]:80 default_server;\n\tserver_name *q;\n\treturn 301 https://$server_name$request_uri;\n}\n\nserver {\n\t# listen on *:443 -> ssl; instead of *:80\n\tlisten 443 ssl http2 default_server;\n\tlisten [::]:443 ssl http2 default_server;\n\n\tserver_name q*;\n\n\tssl_certificate /etc/letsencrypt/live/*q/fullchain.pem;\n\tssl_certificate_key /etc/letsencrypt/live/*q/privkey.pem;\n\tinclude snippets/ssl-params.conf;\n\n\tlocation / {\n\t\t# обратный прокси для next сервера\n\n\t\t# Важно отметить, что вам нужно изменить порт\n\t\t# для приложения на порт, которое приложение использует при запуске\n\t\t# после сборки.\n\t\tproxy_pass http://localhost:8080;\n\t\tproxy_http_version 1.1;\n\t\tproxy_set_header Upgrade $http_upgrade;\n\t\tproxy_set_header Connection 'upgrade';\n\t\tproxy_set_header Host $host;\n\t\tproxy_cache_bypass $http_upgrade;\n\n\t\t# нам нужно удалить эту обработку 404\n\t\t# потому что папка _next и собственная обработка\n\t\t# try_files $uri $uri/ =404;\n\t}\n\n\tlocation ~ /.well-known {\n\t\tallow all;\n\t}\n}"
      },
      "p68": {
        "type": "code",
        "lang": "bash",
        "content": "# Перезапустите службу\n$ sudo service nginx restart"
      },
      "p69": {
        "type": "code",
        "lang": "shell",
        "content": "# Соберите и запустите приложение\n$ npm run build # сборка приложения (npm build script: next build)\n$ npm i -g pm2 # установите pm2, чтобы следующее приложение всегда оставалось в работе*\n$ pm2 start npm --name \"next\" -- start # старт приложения (npm start script: next start)\n"
      },
      "p70": {
        "type": "title",
        "content": "Контакт и ссылки"
      }
    },
    "references": [{
      "name": "Оригинальный GitHub gist",
      "link": "https://gist.github.com/jjsquady/5399d6e1b23f501083a9c262d806e248"
    }]
  },
  "everything-you-need-to-know-about-hardening": {
    "title": "Все, что вам нужно знать о харденинге",
    "tags": "",
    "description": "",
    "pageDescription": "Харденинг относится к процессу обеспечения машины (виртуальной или физической), которая управляет операционной системой и приложениями или услугами хостинга. Целью харденинга является минимизация риска несанкционированного доступа к машине, защитить данные и приложения, размещенные на нем, и предотвратить любую компромизацию системы.",
    "intro": "",
    "timestamp": "",
    "footer": "",
    "toc": {
      "intro": "Intro"
    },
    "content": {}
  },
  "pki-infrastructure-or-how-to-build-your-own-vpn": {
    "title": "Инфраструктура PKI или как построить свой VPN",
    "tags": "",
    "description": "",
    "pageDescription": "Когда-нибудь задумывались о том, как работает ВПН? Я думаю, что эта технология настолько сильно стала частью современного бизнеса и всей его инфрастрруктуры, что мы даже не задумываемся об этом. А стоило бы! Сегодня обсудим то, как мы можем построить нашу собственнуют инфраструктуру ВПН и вообще выясним как это все работает.",
    "intro": "",
    "timestamp": "",
    "footer": "",
    "toc": {
      "intro": "Intro"
    },
    "content": {}
  }
}
